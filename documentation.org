#+title:A set of sequence manipulation code

* Table of Contents                                                     :toc@3:
- [[#reading-and-comparing-sequences-in-a-given-fasta-file][Reading and comparing sequences in a Given FASTA file]]
  - [[#parsing-a-fasta-file][Parsing a FASTA File]]
    - [[#opening-the-file][Opening the file]]
    - [[#putting-the-sequences-of-the-file-in-a-dictionary][Putting the sequences of the file in a dictionary]]
    - [[#printing-file-information][Printing file information]]
    - [[#printing-length-information-of-sequences][Printing length information of sequences]]
    - [[#example-sequence][Example sequence]]
  - [[#comparing-sequences-in-the-file][Comparing sequences in the file]]
    - [[#question][Question]]
    - [[#our-approach][Our Approach]]
    - [[#creating-a-dictionary-storing-identifiers-and-sequence-lengths-and-printing-it][Creating a dictionary storing identifiers and sequence lengths and printing it]]
- [[#identification-and-mapping-of-open-reading-frames-orfs][Identification and Mapping of Open Reading Frames (ORFs)]]
  - [[#question-1][Question]]
  - [[#approach][Approach]]
    - [[#how-we-define-the-open-reading-frames-for-a-sequence][How we define the (open) reading frames for a sequence?]]
    - [[#data-storage-scheme][Data storage scheme]]
    - [[#breaking-down-into-parts][Breaking down into parts]]
  - [[#finding-all-orfs-in-a-single-frame][Finding all ORFs in a single frame]]
    - [[#the-frame_orfs-function][The =frame_orfs()= function]]
    - [[#testing-the-frame_orfs-function][Testing the =frame_orfs()= function]]
    - [[#previous-code][Previous code]]
  - [[#finding-all-the-frames-of-a-sequence][Finding all the frames of a sequence]]
    - [[#finding-reverse-complement-of-sequences][Finding reverse complement of sequences]]
    - [[#the-frame_extract-function][The =frame_extract()= function]]
    - [[#testing-the-frame_extract-function][Testing the =frame_extract()= function]]
  - [[#finding-all-orfs-in-a-sequence][Finding all ORFs in a sequence]]
    - [[#the-sequence_orfs-function][The =sequence_orfs()= function]]
    - [[#testing-the-sequence_orfs-function][Testing the =sequence_orfs()= function]]
  - [[#printing-all-orfs-in-a-sequence][Printing all ORFs in a sequence]]
    -  [[#print_sequence_orfs][=print_sequence_orfs()=]]
    - [[#testing--print_sequence_orfs][Testing  =print_sequence_orfs()=]]
  - [[#comparing-and-printing-the-longest-orf-of-a-sequence][Comparing and printing the longest ORF of a sequence]]

* Reading and comparing sequences in a Given FASTA file
(1) How many records are in the file? A record in a FASTA file is defined as a single-line header, followed by lines of sequence data. The header line is distinguished from the sequence data by a greater-than (">") symbol in the first column. The word following the ">" symbol is the identifier of the sequence, and the rest of the line is an optional description of the entry. There should be no space between the ">" and the first letter of the identifier. 

Separate functions for the following tasks are to be written:
1. Accepting a FASTA file as input from the command line [other arguments if necessary will be accepted later by modifying this code]
2. Reading from a FASTA file and putting sequences into a dictionary
3. Using the dictionary to count and return the number of sequences
** Parsing a FASTA File
*** Opening the file 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py
  #!/usr/bin/python3
  #the following code reads from a FASTA file and puts the sequences in a dictionary
  import sys
  def usage():
      print
      """
      The program allows the user to ....

      Basic Usage:

      python3 fastinfo.py <filename.FASTA> [option1] [option2...]

      """
      return 0

  #now we open the file, which is stored in the second position of the sys.argv[] list
  try:
      f = open(sys.argv[1], 'r')
      print("FASTA File found. Processing...")
  except IOError:
      print("The file does not exist! Please recheck the filename.")
      sys.exit()

#+end_src

#+RESULTS:

*** Putting the sequences of the file in a dictionary
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org
  def multi_FASTA_to_dict(FASTA_file_object):
      """
      This function opens a FASTA file and puts the sequences in a dictionary. 
      """
      sequence_dictionary = {}
      for line in FASTA_file_object:
          line = line.rstrip() #removing the trailing newlines from the FASTA file
          #print(line)
          if line[0] == '>':
              #split the header into a list consisting of the sequence identifier and the description 
              header_word_list = line[1:].split() 
              #identifier would be the first word of the header word list
              identifier = header_word_list[0]
              #print(identifier)
              #initializing an empty entry corresponding to the sequence identifier
              sequence_dictionary[identifier] = ""
              #print(sequence_dictionary[identifier])
          else:
              sequence_dictionary[identifier] = sequence_dictionary[identifier]+line #we concatenate the subsequent lines to the entry corresponding to an identifier
              #print(sequence_dictionary[identifier])

      return sequence_dictionary
#+end_src

#+RESULTS:
: None

*** Printing file information 
Now we print the sequence identifiers in the dictionary and the number of entries in the multi-FASTA file. 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org 
  fast_dict = multi_FASTA_to_dict(f)
  print("\nThe following identifiers have been retrieved:")
  for keys in fast_dict:
      print(keys)
      #print(fast_dict[keys]) #prints all sequences, hence commented out
  print("\nThere are a total of", len(fast_dict), "sequences in the file.")
#+end_src

#+RESULTS:

*** Printing length information of sequences
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org 
  from seqlen_compare import *
  seq_len_compare(fast_dict)
#+end_src

#+RESULTS:

*** Example sequence
#+begin_src python :session gdspyt :tangle ./temp.py
test_sequence="AGGCTTGACCTTGTGCGGCAGCCGGCAGCCGCCGGCCGGCAGGTTGCCGTACGGATCCTCGTCGGCCGCCGTCGCGGGGGCCGCCGGCATCACGGGGGCGGTCGACGCGACCAGCATCGGGGGGAACGGCAACGCATGCACCCGCTCGCCGGTCAGCACGAACGCACCGTTGGCCACCGCCGGCGCGATCGGCGGCACGCCGGCGTCGCTCAACCCGGTCGGCTGGGCGTCCGACGGCACGAAGAAGACATCCACCGGCGGCGCTTCCTGCATGCGTATCGGCGAATAGTCGGCGAAACCGGCGTTGCGGACCGCGCCATGGTCGACGTCGATCGCGAAGCCGGGCTTCGTCGTCGCGAGACCGAACAGCGCGCCGCCCTGGATCTGCGCTTGCGCGCCGGTCGGGTTGACGATGCGGCCCGCATACACGCCGGCCGTCACGCGATGCACGCGCGGTTGTTGCGCTTCGATCGACACTTCCGTCACGTACGCGACGACCGAGCCGGCCGTTTCGTGCATCGCGACGCCCCACGCGTGCCCGGCCGGCAGCGTGCGCGCGCCGTAGCCGGACTTGTCGACGGCCAGCGCGAGCGCCTGCCGATGCGCGGCGTGCTCGGGGCCGGCCAGCCGCGTCATCCGGTAGGCGACCGGATCCTGCCGCGCCGAGTGCGCGAGCTCGTCGACCAGCGTTTCCATCACGAACGCCGTATGCGAGTTGCCGCCCGAGCGCCACGTCTGGACCGGCACGTCGGCCTCGGTCTGATGAACCGATACCTGCATCGGGAAGCCGTACGGGCTGTTCGTCACGCCTTCGGTCAGGCTCGGATCGGTGCCGCGCTTGAGCATCGTCGTGCGCTCGAGCGGCGAGCCCTTCAGCACAGACTGGCCGACGACCACGTGCTGCCAGTCGCGCACGGCGCCGCTGCCGTCCACGCCGATGTCGACGCGATGCAGCACCATCGGGCGGTAATAGCCGCCGCGCAGATCGTCCTCGCGCGTCCAGATCGTCTTGACGGGGCCGAGATGGCCGGCCGCGAGGTACGCGGCGGACACGTGGGCGGCTTCGACCACGTAGTCCGACGTCGGCGTCGAGCGCCGGCCATAGTCGCCGCCCGAGGTCAGCGTGAAGATCTGGACTTTCTCCGGGGCGACGCCGAGCGCCTTCGCGACCGCCGCGCGGTCGGTCGTC"
#+end_src

#+RESULTS:

** Comparing sequences in the file

*** Question 
#+begin_quote
(2) What are the lengths of the sequences in the file? What is the longest sequence and what is the shortest sequence? Is there more than one longest or shortest sequence? What are their identifiers? 
#+end_quote
*** Our Approach 
The way to go about this is:
- Find the length of each seqeunce in the dictionary and put this in another dictionary with keys as the identifiers and values as the length. Use this dictionary for comparison.
- Now, find the longest and shortest sequence and print their identifiers and lengths.
*** Creating a dictionary storing identifiers and sequence lengths and printing it 
#+begin_src python :tangle ./seqlen_compare.py :comments org :mkdirp 
  def seq_len_compare(seq_dict):
      """This function compares the length of DNA sequences in a dictionary
      """

      """first, we create a new sequence dictionary which stores lengths against identifiers
      """
      seq_len_dict = {}
      for keys,values in seq_dict.items():
          seq_len_dict[keys] = len(values)

      #for testing     
      # for keys,values in seq_len_dict.items():
      #     print(keys,values)


      """
      Now we compare the lengths of sequences in the dictionary.
      """

      #1. Maximum Length

      #first we initialize the maximum sequence length to 0
      max = 0
      #next we initialize a variable to store the identifier corresponding to the maximum sequence length
      max_identifier = ''
      #now we create a list which holds all identifiers which have the maximum value
      max_list = []
      for keys,values in seq_len_dict.items():
          if values>max:
              max = values
              max_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the maximum length
      for keys,values in seq_len_dict.items():
          if values==max:
              max_list.append(keys)

      #2. Minimum Length 
      #first we initialize the minimum sequence length to the maximum value obtained in the previous section
      min = max 
      #next we initialize a variable to store the identifier corresponding to the minimum sequence length
      min_identifier = ''
      #now we create a list which holds all identifiers which have the minimum value
      min_list = []
      for keys,values in seq_len_dict.items():
          if values<min:
              min = values
              min_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the minimum length
      for keys,values in seq_len_dict.items():
          if values==min:
              min_list.append(keys)

      """
      Now we print out the values obtained along with their identifiers.
      """
      #1. Print Maximum Length(s)
      print("\nThe following", len(max_list),  "sequence(s) has/have the maximum length of", max, '.')
      for x in range(len(max_list)):
          #print the identifiers in the max_list
          print("\n", max_list[x])

      #2. Print Minimum Length(s)
      print("\nThe following", len(min_list), "sequence(s) has/have the minimum length of", min,'.')
      for x in range(len(min_list)):
          #print the identifiers in the min_list
          print("\n", min_list[x])

      #to exit from the function
      return 0
#+end_src

#+RESULTS:
: None

* Identification and Mapping of Open Reading Frames (ORFs)
** Question 
#+begin_quote
(3) In molecular biology, a reading frame is a way of dividing the DNA sequence of nucleotides into a set of consecutive, non-overlapping triplets (or codons). Depending on where we start, there are six possible reading frames: three in the forward (5' to 3') direction and three in the reverse (3' to 5'). For instance, the three possible forward reading frames for the sequence AGGTGACACCGCAAGCCTTATATTAGC are: 

AGG TGA CAC CGC AAG CCT TAT ATT AGC

A GGT GAC ACC GCA AGC CTT ATA TTA GC

AG GTG ACA CCG CAA GCC TTA TAT TAG C 

These are called reading frames 1, 2, and 3 respectively. An open reading frame (ORF) is the part of a reading frame that has the potential to encode a protein. It starts with a start codon (ATG), and ends with a stop codon (TAA, TAG or TGA). For instance, ATGAAATAG is an ORF of length 9.

Given an input reading frame on the forward strand (1, 2, or 3) your program should be able to:
1. identify all ORFs present in each sequence of the FASTA file, and answer
2. what is the length of the longest ORF in the file?
3. What is the identifier of the sequence containing the longest ORF?
4. For a given sequence identifier, what is the longest ORF contained in the sequence represented by that identifier?
5. What is the starting position of the longest ORF in the sequence that contains it? The position should indicate the character number in the sequence. For instance, the following ORF in reading frame 1:

>sequence1

ATGCCCTAG

starts at position 1.

Note that because the following sequence:

>sequence2

ATGAAAAAA

does not have any stop codon in reading frame 1, we do not consider it to be an ORF in reading frame 1. 
#+end_quote

** Approach 
*** How we define the (open) reading frames for a sequence?
Open Reading Frames are substrings of DNA sequence strings which start with a start codon ATG and end with a stop codon, TAA, TAG or TGA.

Now, a given sequence will have 6 reading frames. Given a sequence, its easy to understand the first 3: we start accepting codons in multiples of 3 from the first position, the second and the third. 

What about the frames 4, 5 and 6? For them, we take the reverse strand, that is, the reverse complement of our sequence and take ORFs in it, as we had done for the forward strand.

The problem with the reverse strand is, we also have to map the starting and ending positions of the ORF, if any.

For this, when we get the starting position of the ORF in a reverse complement string, we use the subtract that position from the total length of the forward sequence. That gives us the starting position of the orf in the reverse direction, in the forward string itself.
*** Data storage scheme
Given the amount of information we have to process, its necessary to define a data structure for the same. 
#+begin_quote
Master Dictionary -> Sequence Dictionary -> Frame Dictionary -> ORF Dictionary[codon_list, starting position, ending position]
#+end_quote
- A dictionary containing all sequence identifers as keys, each of which contain another dictionary. 
  - Each frame containing information about 6 reading frames. For each reading frame:
    - A dictionary, whose keys correspond to an ORF discovered in the reading frame, if ORFs are found at all. Each ORF key will contain a list containing 3 things:
      - A nested list containing the codons of the ORF, from the start through the stop condons
      - Start position of the ORF,
      - Stop position of the ORF,  
#+begin_src python
  orf_dictionary = {
      identifier_1:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}},
      identifier_2:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}}
      .
      .
      .
      identifier_n:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}}}
#+end_src

#+RESULTS:

*** Breaking down into parts
Having defined the data structure, let us break up the scheme of work into granular functions. 
1) Function which takes the sequence, starts from the beginning and detects all ORFs and returns a dictionary of the type:
   #+begin_src python
     orf_dictionary = {
         ORF1:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position],
         ORF2:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position],
         .
         .
         .
         ORFn:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position]}
   #+end_src

   #+RESULTS:
   
2) Function which extracts all frames from a given sequence and returns a dictionary of type:
   #+begin_src python
     frame_dictionary = {
         frame_1:sequence1,
         frame_2:seqeunce2,
         .
         .
         .,
         frame_6:sequence6}
   #+end_src

   #+RESULTS:
   
3) Function which takes *a sequence* and *returns a dictionary* of all the ORFs with their starting and stopping position in /all the frames/ and prints them.

4) Function which *prints* all ORF information of *a sequence*.

5) Function which compares the lengths of ORFs and returns the *longest ORF(s)* of *a sequence*.

   Having done the above, it is easy to scale it up for all FASTA sequences in a file.
   
6) Function which prints ORF information of all sequences in the file.
   
7) Function which compares the ORFs of a file and prints out the longest
   and shortest ORFs.

** Finding all ORFs in a single frame
*** The =frame_orfs()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  def frame_orfs(frame):
      #define the start and stop codons
      start_codon = "ATG"
      # print("Calculating all ORFs in frame of length", len(frame), "...")
      stop_codon_tuple = ("TAA", "TAG", "TGA")

      #trimming the frame (from the end) to number of nucleotides in multiples of 3
      trimmed_frame = ""
      for i in range((len(frame) - (len(frame)%3))):
          trimmed_frame = trimmed_frame + frame[i]

      #now get all the positions of start and stop codons
      start_pos_list = []
      stop_pos_list = []

      #initialize the while loop variable
      h = 0
      while (h <= (len(trimmed_frame) - 3)):
          codon = trimmed_frame[h:h+3]

          #storing the start positions 
          if codon == start_codon:
              start_pos_list.append(h)

          #storing the stop positions 
          if codon in stop_codon_tuple:
              # print(codon)
              stop_pos_list.append(h)

          #incrementing i by 3
          h = h + 3

      # print(start_pos_list)
      # print(stop_pos_list)

      #Now getting the ORFs.     
      orf_dict = {}
      i = 1 #initializing a variable to store the ORF number
      for start_position in start_pos_list:
          # a new list of stop positions is to be built which will contain stop positions after the start position
          new_stop_pos_list = []
          for stop_position in stop_pos_list:
              if stop_position > start_position:
                  new_stop_pos_list.append(stop_position)

          #print(new_stop_pos_list)
          for stop_posi in new_stop_pos_list:
              # print(trimmed_frame[stop_posi:stop_posi+3])
              orf_key = "ORF"+str(i)
              orf_dict[orf_key] = [[],
                                   start_position + 1, #+1 to start indexing from 1
                                   stop_posi + 3]
              for j in range(start_position, stop_posi+1):
                  orf_dict[orf_key][0].append(trimmed_frame[j:j+3])
              #updating ORF number 
              i = i + 1

      return orf_dict

#+end_src

#+RESULTS:

*** Testing the =frame_orfs()= function
#+begin_src python :session gdspyt :tangle no
  orfdict = frame_orfs(test_sequence)
  print("Found", len(orfdict), "sequences in frame.")
  for ORF, info in orfdict.items():
      print(ORF, "\n", info[0], "\n", info[1], info[2])
      # print(ORF, "\n", info[0][0], info[0][1], info[0][2], "...", info[0][-2], info[0][-1], "\n", info[1], info[2])
#+end_src

#+RESULTS:


Thus, we have successfully found all of the ORFs in one single frame.
*** Previous code
#+begin_src python
  #in this function we find all ORFs in a sequence, that is, sequences which start with ATG and end with any of the stop codons TAA, TAG and TGA
  def ORF_find(seq_dictionary):
      """
      This function accepts a sequence dictionary created from identifier:sequence pairs from a multi-FASTA file and returns another sequence dictionary containing identifier:ORF lists.

      """

      """Initializing some necessicities""" 

      #the master dictionary containing all the ORFs from all reading frames along with their positions in each sequence
      orf_dictionary = {}
    
      #Variable to store the reverse complement 
      reverse_complement = ''

      #Tuple containing our stop codons
      stop_codon_tuple = ("TAA", "TAG", "TGA")

      #the start codon
      start_codon = "ATG"

      #initializing the start and stop codon position variables to null values 
      start_index_in_frame = None
      stop_index_in_frame = None

      """Now we enter the loop to check for our coding sequences."""
      for identifiers, sequences in seq_dictionary.items():
          reverse_complement = reverse_complement(values)
          #start going through frames 1, 2 and 3
          codon = ""
          frame_dictionary = {}
          i = 0
          while i<3:
              for j in range(i, (len(sequences) - (i + 3))):
                  codon = values[j:(j + 3)]
                  if codon == start_codon:
                      start_index_in_frame = j
                  if codon in stop_codon_tuple:
                      stop_index_in_frame = j
                  #skipping 3 codons and re-entering the loop     
                  j = j + 3

              frame_list = []
              orf_codon_list = []
              #Now check if the reading frame actually contains an ORF
              if (start_index_in_frame != None && stop_index_in_frame != None):

                  #continue from the position where start_codon was encountered 
                  j = start_index_in_frame
                
                  #stop at stop codon's position 
                  while (j < stop_index_in_frame):
                      #build the codon list in the ORF 
                      orf_codon_list.append(sequence[j:j+3])
                      j + 3
                  #building the frame information list
                  frame_list.append(orf_codon_list)
                  frame_list.append(start_index_in_frame)
                  frame_list.append(stop_index_in_frame)
                
                  frame_dictionary["Frame_" + str(i+1)] = frame_list

          orf_dictionary[identifiers] = frame_dictionary
#+end_src

#+RESULTS:

Test for the None assignment and condition

#+begin_src python :results output
  test = None
  if test==None:
      print("The value of the variable is", test)
  if test != None:
      print("LOL")
#+end_src

#+RESULTS:
: The value of the variable is None

Test for slicing behavior

#+begin_src python :results output
  string = "BCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  #the above string contains only 36 characters, thus the last index should be 35.
  #thus printing from 0 index through 36 should give back the string from index 0 through 35, which is 0 to 36-1
  print(string[0:])
#+end_src

#+RESULTS:
: BCDEFGHIJKLMNOPQRSTUVWXYZ0123456789

** Finding all the frames of a sequence
The first 3 frames of the sequence can be found by starting from the first, second and third position, respectively, of the sequence in the forward direction.
For the next 3 frames, the reverse complement of the sequence has to be used. 
*** Finding reverse complement of sequences
**** Revese of a Sequence
***** The =sequence_reverse()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  #This is a simple function to reverse a string
  def sequence_reverse(sequence):
      """
      This program finds the reverse of the sequence entered. 
      """
      #first we initialize the string variable which will contain our reversed string
      reversed_sequence = ''
      #next we initialize our loop variable to the value of the last index of 'sequence'
      i=len(sequence)-1
      #we use a while loop, which continues till i is greater than or equal to zero 
      while i>=0:
          #we concatenate each letter from the end of the sequence entered to form a new string which has the order reversed
          reversed_sequence = reversed_sequence+sequence[i]
          #in each iteration we decrease the value of the variable i to maintain the loop condition
          i=i-1

      #finally, exit from the function and return the reversed sequence    
      return reversed_sequence
#+end_src

#+RESULTS:
***** Testing the =sequence_reverse()= function 
#+begin_src python :session gdspyt :results output  
print(sequence_reverse(test_sequence))
#+end_src

#+RESULTS:
: CTGCTGGCTGGCGCGCCGCCAGCGCTTCCGCGAGCCGCAGCGGGGCCTCTTTCAGGTCTAGAAGTGCGACTGGAGCCCGCCGCTGATACCGGCCGCGAGCTGCGGCTGCAGCCTGATGCACCAGCTTCGGCGGGTGCACAGGCGGCGCATGGAGCGCCGGCCGGTAGAGCCGGGGCAGTTCTGCTAGACCTGCGCGCTCCTGCTAGACGCGCCGCCGATAATGGCGGGCTACCACGACGTAGCGCAGCTGTAGCCGCACCTGCCGTCGCCGCGGCACGCGCTGACCGTCGTGCACCAGCAGCCGGTCAGACACGACTTCCCGAGCGGCGAGCTCGCGTGCTGCTACGAGTTCGCGCCGTGGCTAGGCTCGGACTGGCTTCCGCACTGCTTGTCGGGCATGCCGAAGGGCTACGTCCATAGCCAAGTAGTCTGGCTCCGGCTGCACGGCCAGGTCTGCACCGCGAGCCCGCCGTTGAGCGTATGCCGCAAGCACTACCTTTGCGACCAGCTGCTCGAGCGCGTGAGCCGCGCCGTCCTAGGCCAGCGGATGGCCTACTGCGCCGACCGGCCGGGGCTCGTGCGGCGCGTAGCCGTCCGCGAGCGCGACCGGCAGCTGTTCAGGCCGATGCCGCGCGCGTGCGACGGCCGGCCCGTGCGCACCCCGCAGCGCTACGTGCTTTGCCGGCCGAGCCAGCAGCGCATGCACTGCCTTCACAGCTAGCTTCGCGTTGTTGGCGCGCACGTAGCGCACTGCCGGCCGCACATACGCCCGGCGTAGCAGTTGGGCTGGCCGCGCGTTCGCGTCTAGGTCCCGCCGCGCGACAAGCCAGAGCGCTGCTGCTTCGGGCCGAAGCGCTAGCTGCAGCTGGTACCGCGCCAGGCGTTGCGGCCAAAGCGGCTGATAAGCGGCTATGCGTACGTCCTTCGCGGCGGCCACCTACAGAAGAAGCACGGCAGCCTGCGGGTCGGCTGGCCCAACTCGCTGCGGCCGCACGGCGGCTAGCGCGGCCGCCACCGGTTGCCACGCAAGCACGACTGGCCGCTCGCCCACGTACGCAACGGCAAGGGGGGCTACGACCAGCGCAGCTGGCGGGGGCACTACGGCCGCCGGGGGCGCTGCCGCCGGCTGCTCCTAGGCATGCCGTTGGACGGCCGGCCGCCGACGGCCGACGGCGTGTTCCAGTTCGGA

**** Complement of a sequence
***** The =dna_complement()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  #this function returns the complement of a DNA sequence entered, NOT the reverse complement
  def dna_complement(sequence):
      """
      This function returns the complementary sequence of a DNA sequence entered.

      """
      #first we define a dictionary containing all the bases and their complements, even in lowecase
      bases_dict = {"A":"T", "a":"t", "C":"G", "c":"g", "G":"C", "g":"c", "T":"A", "t":"a", "N":"N", "n":"n"}

      #we initialize a string variable to store the complementary sequence
      complement = ''

      #next we loop over our sequence and make a new complementary string
      for i in sequence:
          complement = complement + bases_dict[i]

      #finally, return the complement sequence and exit from the function
      return complement
#+end_src

#+RESULTS:

***** Testing the =dna_complement()= function
#+begin_src python :session gdspyt :results output  
print(dna_complement(test_sequence))
#+end_src

#+RESULTS:
: TCCGAACTGGAACACGCCGTCGGCCGTCGGCGGCCGGCCGTCCAACGGCATGCCTAGGAGCAGCCGGCGGCAGCGCCCCCGGCGGCCGTAGTGCCCCCGCCAGCTGCGCTGGTCGTAGCCCCCCTTGCCGTTGCGTACGTGGGCGAGCGGCCAGTCGTGCTTGCGTGGCAACCGGTGGCGGCCGCGCTAGCCGCCGTGCGGCCGCAGCGAGTTGGGCCAGCCGACCCGCAGGCTGCCGTGCTTCTTCTGTAGGTGGCCGCCGCGAAGGACGTACGCATAGCCGCTTATCAGCCGCTTTGGCCGCAACGCCTGGCGCGGTACCAGCTGCAGCTAGCGCTTCGGCCCGAAGCAGCAGCGCTCTGGCTTGTCGCGCGGCGGGACCTAGACGCGAACGCGCGGCCAGCCCAACTGCTACGCCGGGCGTATGTGCGGCCGGCAGTGCGCTACGTGCGCGCCAACAACGCGAAGCTAGCTGTGAAGGCAGTGCATGCGCTGCTGGCTCGGCCGGCAAAGCACGTAGCGCTGCGGGGTGCGCACGGGCCGGCCGTCGCACGCGCGCGGCATCGGCCTGAACAGCTGCCGGTCGCGCTCGCGGACGGCTACGCGCCGCACGAGCCCCGGCCGGTCGGCGCAGTAGGCCATCCGCTGGCCTAGGACGGCGCGGCTCACGCGCTCGAGCAGCTGGTCGCAAAGGTAGTGCTTGCGGCATACGCTCAACGGCGGGCTCGCGGTGCAGACCTGGCCGTGCAGCCGGAGCCAGACTACTTGGCTATGGACGTAGCCCTTCGGCATGCCCGACAAGCAGTGCGGAAGCCAGTCCGAGCCTAGCCACGGCGCGAACTCGTAGCAGCACGCGAGCTCGCCGCTCGGGAAGTCGTGTCTGACCGGCTGCTGGTGCACGACGGTCAGCGCGTGCCGCGGCGACGGCAGGTGCGGCTACAGCTGCGCTACGTCGTGGTAGCCCGCCATTATCGGCGGCGCGTCTAGCAGGAGCGCGCAGGTCTAGCAGAACTGCCCCGGCTCTACCGGCCGGCGCTCCATGCGCCGCCTGTGCACCCGCCGAAGCTGGTGCATCAGGCTGCAGCCGCAGCTCGCGGCCGGTATCAGCGGCGGGCTCCAGTCGCACTTCTAGACCTGAAAGAGGCCCCGCTGCGGCTCGCGGAAGCGCTGGCGGCGCGCCAGCCAGCAG

**** Reverse complement of a sequence
***** The =reverse_complement()= function 
#+begin_src python :session gdspyt :tangle ./temp.py
  #a simple function which calls the reverse string and sequence complement functions to calculate the reverse complements
  def reverse_complement(sequence):
      return(dna_complement(sequence_reverse(sequence)))
    
#+end_src

#+RESULTS:
***** Testing the =reverse_complement()= function
#+begin_src python :session gdspyt :results output
print(reverse_complement(test_sequence))
#+end_src

#+RESULTS:
: GACGACCGACCGCGCGGCGGTCGCGAAGGCGCTCGGCGTCGCCCCGGAGAAAGTCCAGATCTTCACGCTGACCTCGGGCGGCGACTATGGCCGGCGCTCGACGCCGACGTCGGACTACGTGGTCGAAGCCGCCCACGTGTCCGCCGCGTACCTCGCGGCCGGCCATCTCGGCCCCGTCAAGACGATCTGGACGCGCGAGGACGATCTGCGCGGCGGCTATTACCGCCCGATGGTGCTGCATCGCGTCGACATCGGCGTGGACGGCAGCGGCGCCGTGCGCGACTGGCAGCACGTGGTCGTCGGCCAGTCTGTGCTGAAGGGCTCGCCGCTCGAGCGCACGACGATGCTCAAGCGCGGCACCGATCCGAGCCTGACCGAAGGCGTGACGAACAGCCCGTACGGCTTCCCGATGCAGGTATCGGTTCATCAGACCGAGGCCGACGTGCCGGTCCAGACGTGGCGCTCGGGCGGCAACTCGCATACGGCGTTCGTGATGGAAACGCTGGTCGACGAGCTCGCGCACTCGGCGCGGCAGGATCCGGTCGCCTACCGGATGACGCGGCTGGCCGGCCCCGAGCACGCCGCGCATCGGCAGGCGCTCGCGCTGGCCGTCGACAAGTCCGGCTACGGCGCGCGCACGCTGCCGGCCGGGCACGCGTGGGGCGTCGCGATGCACGAAACGGCCGGCTCGGTCGTCGCGTACGTGACGGAAGTGTCGATCGAAGCGCAACAACCGCGCGTGCATCGCGTGACGGCCGGCGTGTATGCGGGCCGCATCGTCAACCCGACCGGCGCGCAAGCGCAGATCCAGGGCGGCGCGCTGTTCGGTCTCGCGACGACGAAGCCCGGCTTCGCGATCGACGTCGACCATGGCGCGGTCCGCAACGCCGGTTTCGCCGACTATTCGCCGATACGCATGCAGGAAGCGCCGCCGGTGGATGTCTTCTTCGTGCCGTCGGACGCCCAGCCGACCGGGTTGAGCGACGCCGGCGTGCCGCCGATCGCGCCGGCGGTGGCCAACGGTGCGTTCGTGCTGACCGGCGAGCGGGTGCATGCGTTGCCGTTCCCCCCGATGCTGGTCGCGTCGACCGCCCCCGTGATGCCGGCGGCCCCCGCGACGGCGGCCGACGAGGATCCGTACGGCAACCTGCCGGCCGGCGGCTGCCGGCTGCCGCACAAGGTCAAGCCT

*** The =frame_extract()= function
#+begin_src python :session gdspyt :tangle ./temp.py 
  def frame_extract(sequence):
      """This function extracts all the 6 ORFs from a given sequence."""

      #initializing the dictionary which will store all the sequences of all the frames 
      frame_dictionary = {}

      #this variable stores the frame numbers 
      frame_no = 1

      #loop extracting frames 1, 2 and 3
      for i in range(3):
          frame_name = "Frame" + str(frame_no)
          frame_dictionary[frame_name] = sequence[i:]
          frame_no = frame_no + 1

      # print(frame_no)

      sequence_reverse_complement = reverse_complement(sequence)

      #loop extracting frames 4, 5, and 6
      for i in range(3):
          frame_name = "Frame" + str(frame_no)
          frame_dictionary[frame_name] = sequence_reverse_complement[i:]
          frame_no = frame_no + 1

      # print(frame_no)

      return(frame_dictionary)
#+end_src

#+RESULTS:

*** Testing the =frame_extract()= function
#+begin_src python :session gdspyt :tangle no
  frm_dic = frame_extract(test_sequence)
  for keys, items in frm_dic.items():
      print(keys, "\n", items, "\n")
#+end_src

#+RESULTS:
: None

** Finding all ORFs in a sequence
To find all the ORFs in a sequence, we simply pass a sequence to a function which will call  =frame_extract()= to get a dictionary of frames. Another loop will pass the entries of this frame dictionary to =frame_orfs()= function, to get all the ORFs in the frame. These will be stored in another dictionary and returned.

*** The =sequence_orfs()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  def sequence_orfs(sequence):
      """This function finds and returns all the ORFs in all frames of a sequence."""
      #initializing the dictionary to store all the frame information of the sequence 
      sequence_orfs_dictionary = {}

      #calling the frame_extract() to find all the frames and store it in frames_dictionary variable 
      frames_dictionary = frame_extract(sequence)

      #this loop goes through all the frames in the dictionary, calls the frame_orfs() function for each frame and stores the output in frames_dictionary.    
      for frame, frame_sequence in frames_dictionary.items():
          sequence_orfs_dictionary[frame] = frame_orfs(frame_sequence)

      #for frame 5, 6, and 7, which are the reverse complement frames, we need to alter the start and stop positions of the frame, so that they are with respect to the forward sequence

      reverse_frames_tuple = ("Frame4", "Frame5", "Frame6")

      #calculating the length of the sequence
      seqlen = len(sequence)

      # now altering the start and stop positions 
      for frame, ORF_dict in sequence_orfs_dictionary.items():
          if frame in reverse_frames_tuple:
              for orfs, info in ORF_dict.items():
                  info[1] = seqlen - info[1]
                  info[2] = seqlen - info[2]

      return sequence_orfs_dictionary
#+end_src

*** Testing the =sequence_orfs()= function
#+begin_src python :session gdspyt :tangle no
  print(sequence_orfs(test_sequence))
#+end_src
** Printing all ORFs in a sequence 
Now we take the have to print the output from the =sequence_orfs()= function
***  =print_sequence_orfs()= 
#+begin_src python :session gdspyt :tangle ./temp.py
  def print_sequence_orfs(sequence):
      """This function prints the ORF information of a sequence in a presentable format."""

      seq_orf_info = sequence_orfs(sequence)

      for frame, frame_dict in seq_orf_info.items():
          print("** _ _ _ _ _ _", frame, "_ _ _ _ _ _")
          print("Retrieving", len(frame_dict), "sequences in", frame, "...")
          for orf, orf_dict in frame_dict.items():
              print("***", orf, "\n", orf_dict[0][0], orf_dict[0][1], "...", orf_dict[0][-2], orf_dict[0][-1])
              print(" ", orf_dict[1], "           ", orf_dict[2])

      return 0
#+end_src
*** Testing  =print_sequence_orfs()= 
#+begin_src python :session gdspyt :tangle ./temp.py
  print_sequence_orfs(test_sequence)
#+end_src
** Comparing and printing the longest ORF of a sequence 
