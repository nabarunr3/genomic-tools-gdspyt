#+title:A set of sequence manipulation code

* Table of Contents                                                 :toc@2:
- [[#reading-and-comparing-sequences-in-a-given-fasta-file][Reading and comparing sequences in a Given FASTA file]]
  - [[#parsing-a-fasta-file][Parsing a FASTA File]]
  - [[#comparing-sequences-in-the-file][Comparing sequences in the file]]
- [[#identification-and-mapping-of-open-reading-frames-orfs][Identification and Mapping of Open Reading Frames (ORFs)]]
  - [[#question][Question]]
  - [[#approach][Approach]]
  - [[#finding-all-orfs-in-a-single-frame][Finding all ORFs in a single frame]]
  - [[#finding-all-the-frames-of-a-sequence][Finding all the frames of a sequence]]
  - [[#finding-all-orfs-in-a-sequence][Finding all ORFs in a sequence]]
  - [[#printing-all-orfs-in-a-sequence][Printing all ORFs in a sequence]]
  - [[#comparing-and-printing-the-longest-orfs-of-a-sequence][Comparing and printing the longest ORFs of a sequence]]
  - [[#printing-orf-information-of-all-sequences-in-a-file][Printing ORF information of all sequences in a file]]
  - [[#printing-the-longest-and-shortest-orfs-among-all-sequences-in-a-file][Printing the longest and shortest ORFs among all sequences in a file]]
- [[#mapping-repeats-in-the-file][Mapping Repeats in the File]]
  - [[#question-1][Question]]
  - [[#our-approach][Our Approach]]
  - [[#finding-number-of-repeats-of-a-given-length-in-a-given-sequence][Finding number of repeats of a given length in a given sequence]]

* Reading and comparing sequences in a Given FASTA file
(1) How many records are in the file? A record in a FASTA file is defined as a single-line header, followed by lines of sequence data. The header line is distinguished from the sequence data by a greater-than (">") symbol in the first column. The word following the ">" symbol is the identifier of the sequence, and the rest of the line is an optional description of the entry. There should be no space between the ">" and the first letter of the identifier. 

Separate functions for the following tasks are to be written:
1. Accepting a FASTA file as input from the command line [other arguments if necessary will be accepted later by modifying this code]
2. Reading from a FASTA file and putting sequences into a dictionary
3. Using the dictionary to count and return the number of sequences
** Parsing a FASTA File
*** Opening the file 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py
  #!/usr/bin/python3
  #the following code reads from a FASTA file and puts the sequences in a dictionary
  import sys
  def usage():
      print
      """
      The program allows the user to ....

      Basic Usage:

      python3 fastinfo.py <filename.FASTA> [option1] [option2...]

      """
      return 0

  #now we open the file, which is stored in the second position of the sys.argv[] list
  try:
      f = open(sys.argv[1], 'r')
      print("FASTA File found. Processing...")
  except IOError:
      print("The file does not exist! Please recheck the filename.")
      sys.exit()

#+end_src

#+RESULTS:

*** Putting the sequences of the file in a dictionary
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org
  def multi_FASTA_to_dict(FASTA_file_object):
      """
      This function opens a FASTA file and puts the sequences in a dictionary. 
      """
      sequence_dictionary = {}
      for line in FASTA_file_object:
          line = line.rstrip() #removing the trailing newlines from the FASTA file
          #print(line)
          if line[0] == '>':
              #split the header into a list consisting of the sequence identifier and the description 
              header_word_list = line[1:].split() 
              #identifier would be the first word of the header word list
              identifier = header_word_list[0]
              #print(identifier)
              #initializing an empty entry corresponding to the sequence identifier
              sequence_dictionary[identifier] = ""
              #print(sequence_dictionary[identifier])
          else:
              sequence_dictionary[identifier] = sequence_dictionary[identifier]+line #we concatenate the subsequent lines to the entry corresponding to an identifier
              #print(sequence_dictionary[identifier])

      return sequence_dictionary
#+end_src

#+RESULTS:
: None

*** Printing file information 
Now we print the sequence identifiers in the dictionary and the number of entries in the multi-FASTA file. 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org 
  fast_dict = multi_FASTA_to_dict(f)
  print("\nThe following identifiers have been retrieved:")
  for keys in fast_dict:
      print(keys)
      #print(fast_dict[keys]) #prints all sequences, hence commented out
  print("\nThere are a total of", len(fast_dict), "sequences in the file.")
#+end_src

#+RESULTS:

*** Printing length information of sequences
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org 
  from seqlen_compare import *
  seq_len_compare(fast_dict)
#+end_src

#+RESULTS:

*** Example sequence
#+begin_src python :session gdspyt :tangle ./temp.py
test_sequence="AGGCTTGACCTTGTGCGGCAGCCGGCAGCCGCCGGCCGGCAGGTTGCCGTACGGATCCTCGTCGGCCGCCGTCGCGGGGGCCGCCGGCATCACGGGGGCGGTCGACGCGACCAGCATCGGGGGGAACGGCAACGCATGCACCCGCTCGCCGGTCAGCACGAACGCACCGTTGGCCACCGCCGGCGCGATCGGCGGCACGCCGGCGTCGCTCAACCCGGTCGGCTGGGCGTCCGACGGCACGAAGAAGACATCCACCGGCGGCGCTTCCTGCATGCGTATCGGCGAATAGTCGGCGAAACCGGCGTTGCGGACCGCGCCATGGTCGACGTCGATCGCGAAGCCGGGCTTCGTCGTCGCGAGACCGAACAGCGCGCCGCCCTGGATCTGCGCTTGCGCGCCGGTCGGGTTGACGATGCGGCCCGCATACACGCCGGCCGTCACGCGATGCACGCGCGGTTGTTGCGCTTCGATCGACACTTCCGTCACGTACGCGACGACCGAGCCGGCCGTTTCGTGCATCGCGACGCCCCACGCGTGCCCGGCCGGCAGCGTGCGCGCGCCGTAGCCGGACTTGTCGACGGCCAGCGCGAGCGCCTGCCGATGCGCGGCGTGCTCGGGGCCGGCCAGCCGCGTCATCCGGTAGGCGACCGGATCCTGCCGCGCCGAGTGCGCGAGCTCGTCGACCAGCGTTTCCATCACGAACGCCGTATGCGAGTTGCCGCCCGAGCGCCACGTCTGGACCGGCACGTCGGCCTCGGTCTGATGAACCGATACCTGCATCGGGAAGCCGTACGGGCTGTTCGTCACGCCTTCGGTCAGGCTCGGATCGGTGCCGCGCTTGAGCATCGTCGTGCGCTCGAGCGGCGAGCCCTTCAGCACAGACTGGCCGACGACCACGTGCTGCCAGTCGCGCACGGCGCCGCTGCCGTCCACGCCGATGTCGACGCGATGCAGCACCATCGGGCGGTAATAGCCGCCGCGCAGATCGTCCTCGCGCGTCCAGATCGTCTTGACGGGGCCGAGATGGCCGGCCGCGAGGTACGCGGCGGACACGTGGGCGGCTTCGACCACGTAGTCCGACGTCGGCGTCGAGCGCCGGCCATAGTCGCCGCCCGAGGTCAGCGTGAAGATCTGGACTTTCTCCGGGGCGACGCCGAGCGCCTTCGCGACCGCCGCGCGGTCGGTCGTC"
#+end_src

#+RESULTS:

** Comparing sequences in the file

*** Question 
#+begin_quote
(2) What are the lengths of the sequences in the file? What is the longest sequence and what is the shortest sequence? Is there more than one longest or shortest sequence? What are their identifiers? 
#+end_quote
*** Our Approach 
The way to go about this is:
- Find the length of each seqeunce in the dictionary and put this in another dictionary with keys as the identifiers and values as the length. Use this dictionary for comparison.
- Now, find the longest and shortest sequence and print their identifiers and lengths.
*** Creating a dictionary storing identifiers and sequence lengths and printing it 
#+begin_src python :tangle ./seqlen_compare.py :comments org :mkdirp 
  def seq_len_compare(seq_dict):
      """This function compares the length of DNA sequences in a dictionary
      """

      """first, we create a new sequence dictionary which stores lengths against identifiers
      """
      seq_len_dict = {}
      for keys,values in seq_dict.items():
          seq_len_dict[keys] = len(values)

      #for testing     
      # for keys,values in seq_len_dict.items():
      #     print(keys,values)


      """
      Now we compare the lengths of sequences in the dictionary.
      """

      #1. Maximum Length

      #first we initialize the maximum sequence length to 0
      max = 0
      #next we initialize a variable to store the identifier corresponding to the maximum sequence length
      max_identifier = ''
      #now we create a list which holds all identifiers which have the maximum value
      max_list = []
      for keys,values in seq_len_dict.items():
          if values>max:
              max = values
              max_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the maximum length
      for keys,values in seq_len_dict.items():
          if values==max:
              max_list.append(keys)

      #2. Minimum Length 
      #first we initialize the minimum sequence length to the maximum value obtained in the previous section
      min = max 
      #next we initialize a variable to store the identifier corresponding to the minimum sequence length
      min_identifier = ''
      #now we create a list which holds all identifiers which have the minimum value
      min_list = []
      for keys,values in seq_len_dict.items():
          if values<min:
              min = values
              min_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the minimum length
      for keys,values in seq_len_dict.items():
          if values==min:
              min_list.append(keys)

      """
      Now we print out the values obtained along with their identifiers.
      """
      #1. Print Maximum Length(s)
      print("\nThe following", len(max_list),  "sequence(s) has/have the maximum length of", max, '.')
      for x in range(len(max_list)):
          #print the identifiers in the max_list
          print("\n", max_list[x])

      #2. Print Minimum Length(s)
      print("\nThe following", len(min_list), "sequence(s) has/have the minimum length of", min,'.')
      for x in range(len(min_list)):
          #print the identifiers in the min_list
          print("\n", min_list[x])

      #to exit from the function
      return 0
#+end_src

#+RESULTS:
: None

* Identification and Mapping of Open Reading Frames (ORFs)
** Question 
#+begin_quote
(3) In molecular biology, a reading frame is a way of dividing the DNA sequence of nucleotides into a set of consecutive, non-overlapping triplets (or codons). Depending on where we start, there are six possible reading frames: three in the forward (5' to 3') direction and three in the reverse (3' to 5'). For instance, the three possible forward reading frames for the sequence AGGTGACACCGCAAGCCTTATATTAGC are: 

AGG TGA CAC CGC AAG CCT TAT ATT AGC

A GGT GAC ACC GCA AGC CTT ATA TTA GC

AG GTG ACA CCG CAA GCC TTA TAT TAG C 

These are called reading frames 1, 2, and 3 respectively. An open reading frame (ORF) is the part of a reading frame that has the potential to encode a protein. It starts with a start codon (ATG), and ends with a stop codon (TAA, TAG or TGA). For instance, ATGAAATAG is an ORF of length 9.

Given an input reading frame on the forward strand (1, 2, or 3) your program should be able to:
1. identify all ORFs present in each sequence of the FASTA file, and answer
2. what is the length of the longest ORF in the file?
3. What is the identifier of the sequence containing the longest ORF?
4. For a given sequence identifier, what is the longest ORF contained in the sequence represented by that identifier?
5. What is the starting position of the longest ORF in the sequence that contains it? The position should indicate the character number in the sequence. For instance, the following ORF in reading frame 1:

>sequence1

ATGCCCTAG

starts at position 1.

Note that because the following sequence:

>sequence2

ATGAAAAAA

does not have any stop codon in reading frame 1, we do not consider it to be an ORF in reading frame 1. 
#+end_quote

** Approach 
*** How we define the (open) reading frames for a sequence?
Open Reading Frames are substrings of DNA sequence strings which start with a start codon ATG and end with a stop codon, TAA, TAG or TGA.

Now, a given sequence will have 6 reading frames. Given a sequence, its easy to understand the first 3: we start accepting codons in multiples of 3 from the first position, the second and the third. 

What about the frames 4, 5 and 6? For them, we take the reverse strand, that is, the reverse complement of our sequence and take ORFs in it, as we had done for the forward strand.

The problem with the reverse strand is, we also have to map the starting and ending positions of the ORF, if any.

For this, when we get the starting position of the ORF in a reverse complement string, we use the subtract that position from the total length of the forward sequence. That gives us the starting position of the orf in the reverse direction, in the forward string itself.
*** Data storage scheme
Given the amount of information we have to process, its necessary to define a data structure for the same. 
#+begin_quote
Master Dictionary -> Sequence Dictionary -> Frame Dictionary -> ORF Dictionary[codon_list, starting position, ending position]
#+end_quote
- A dictionary containing all sequence identifers as keys, each of which contain another dictionary. 
  - Each frame containing information about 6 reading frames. For each reading frame:
    - A dictionary, whose keys correspond to an ORF discovered in the reading frame, if ORFs are found at all. Each ORF key will contain a list containing 3 things:
      - A nested list containing the codons of the ORF, from the start through the stop condons
      - Start position of the ORF,
      - Stop position of the ORF,  
#+begin_src python
  orf_dictionary = {
      identifier_1:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}},
      identifier_2:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}}
      .
      .
      .
      identifier_n:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}}}
#+end_src

#+RESULTS:

*** Breaking down into parts
Having defined the data structure, let us break up the scheme of work into granular functions. 
1) [X] Function which takes the sequence, starts from the beginning and detects all ORFs and returns a dictionary of the type:
   #+begin_src python
     orf_dictionary = {
         ORF1:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position],
         ORF2:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position],
         .
         .
         .
         ORFn:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position]}
   #+end_src

   #+RESULTS:
   
2) [X] Function which extracts all frames from a given sequence and returns a dictionary of type:
   #+begin_src python
     frame_dictionary = {
         frame_1:sequence1,
         frame_2:seqeunce2,
         .
         .
         .,
         frame_6:sequence6}
   #+end_src
:
   #+RESULTS:
   
3) [X] Function which takes *a sequence* and *returns a dictionary* of all the ORFs with their starting and stopping position in /all the frames/ and prints them.

4) [X] Function which *prints* all ORF information of *a sequence*.

5) [X] Function which compares the lengths of ORFs and returns the *longest and shortest ORF(s)* of *a sequence*.

   Having done the above, it is easy to scale it up for all FASTA sequences in a file.
   
6) [X] Function which prints ORF information of all sequences in the file.
   
7) [X] Function which compares the ORFs of a file and prints out the longest
   and shortest ORFs.

** Finding all ORFs in a single frame
*** The =frame_orfs()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  def frame_orfs(frame):
      #define the start and stop codons
      start_codon = "ATG"
      # print("Calculating all ORFs in frame of length", len(frame), "...")
      stop_codon_tuple = ("TAA", "TAG", "TGA")

      #trimming the frame (from the end) to number of nucleotides in multiples of 3
      trimmed_frame = ""
      for i in range((len(frame) - (len(frame)%3))):
          trimmed_frame = trimmed_frame + frame[i]

      #now get all the positions of start and stop codons
      start_pos_list = []
      stop_pos_list = []

      #initialize the while loop variable
      h = 0
      while (h <= (len(trimmed_frame) - 3)):
          codon = trimmed_frame[h:h+3]

          #storing the start positions 
          if codon == start_codon:
              start_pos_list.append(h)

          #storing the stop positions 
          if codon in stop_codon_tuple:
              # print(codon)
              stop_pos_list.append(h)

          #incrementing i by 3
          h = h + 3

      # print(start_pos_list)
      # print(stop_pos_list)

      #Now getting the ORFs.     
      orf_dict = {}
      i = 1 #initializing a variable to store the ORF number
      for start_position in start_pos_list:
          # a new list of stop positions is to be built which will contain stop positions after the start position
          new_stop_pos_list = []
          for stop_position in stop_pos_list:
              if stop_position > start_position:
                  new_stop_pos_list.append(stop_position)

          #print(new_stop_pos_list)
          for stop_posi in new_stop_pos_list:
              # print(trimmed_frame[stop_posi:stop_posi+3])
              orf_key = "ORF"+str(i)
              orf_dict[orf_key] = [[],
                                   start_position + 1, #+1 to start indexing from 1
                                   stop_posi + 3]
              for j in range(start_position, stop_posi+1):
                  orf_dict[orf_key][0].append(trimmed_frame[j:j+3])
              #updating ORF number 
              i = i + 1

      return orf_dict

#+end_src

#+RESULTS:

*** Testing the =frame_orfs()= function
#+begin_src python :session gdspyt :tangle no
  orfdict = frame_orfs(test_sequence)
  print("Found", len(orfdict), "sequences in frame.")
  for ORF, info in orfdict.items():
      print(ORF, "\n", info[0], "\n", info[1], info[2])
      # print(ORF, "\n", info[0][0], info[0][1], info[0][2], "...", info[0][-2], info[0][-1], "\n", info[1], info[2])
#+end_src

#+RESULTS:


Thus, we have successfully found all of the ORFs in one single frame.
*** Previous code
#+begin_src python
  #in this function we find all ORFs in a sequence, that is, sequences which start with ATG and end with any of the stop codons TAA, TAG and TGA
  def ORF_find(seq_dictionary):
      """
      This function accepts a sequence dictionary created from identifier:sequence pairs from a multi-FASTA file and returns another sequence dictionary containing identifier:ORF lists.

      """

      """Initializing some necessicities""" 

      #the master dictionary containing all the ORFs from all reading frames along with their positions in each sequence
      orf_dictionary = {}
    
      #Variable to store the reverse complement 
      reverse_complement = ''

      #Tuple containing our stop codons
      stop_codon_tuple = ("TAA", "TAG", "TGA")

      #the start codon
      start_codon = "ATG"

      #initializing the start and stop codon position variables to null values 
      start_index_in_frame = None
      stop_index_in_frame = None

      """Now we enter the loop to check for our coding sequences."""
      for identifiers, sequences in seq_dictionary.items():
          reverse_complement = reverse_complement(values)
          #start going through frames 1, 2 and 3
          codon = ""
          frame_dictionary = {}
          i = 0
          while i<3:
              for j in range(i, (len(sequences) - (i + 3))):
                  codon = values[j:(j + 3)]
                  if codon == start_codon:
                      start_index_in_frame = j
                  if codon in stop_codon_tuple:
                      stop_index_in_frame = j
                  #skipping 3 codons and re-entering the loop     
                  j = j + 3

              frame_list = []
              orf_codon_list = []
              #Now check if the reading frame actually contains an ORF
              if (start_index_in_frame != None && stop_index_in_frame != None):

                  #continue from the position where start_codon was encountered 
                  j = start_index_in_frame
                
                  #stop at stop codon's position 
                  while (j < stop_index_in_frame):
                      #build the codon list in the ORF 
                      orf_codon_list.append(sequence[j:j+3])
                      j + 3
                  #building the frame information list
                  frame_list.append(orf_codon_list)
                  frame_list.append(start_index_in_frame)
                  frame_list.append(stop_index_in_frame)
                
                  frame_dictionary["Frame_" + str(i+1)] = frame_list

          orf_dictionary[identifiers] = frame_dictionary
#+end_src

#+RESULTS:

Test for the None assignment and condition

#+begin_src python :results output
  test = None
  if test==None:
      print("The value of the variable is", test)
  if test != None:
      print("LOL")
#+end_src

#+RESULTS:
: The value of the variable is None

Test for slicing behavior

#+begin_src python :results output
  string = "BCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  #the above string contains only 36 characters, thus the last index should be 35.
  #thus printing from 0 index through 36 should give back the string from index 0 through 35, which is 0 to 36-1
  print(string[0:])
#+end_src

#+RESULTS:
: BCDEFGHIJKLMNOPQRSTUVWXYZ0123456789

** Finding all the frames of a sequence
The first 3 frames of the sequence can be found by starting from the first, second and third position, respectively, of the sequence in the forward direction.
For the next 3 frames, the reverse complement of the sequence has to be used. 
*** Finding reverse complement of sequences
**** Revese of a Sequence
***** The =sequence_reverse()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  #This is a simple function to reverse a string
  def sequence_reverse(sequence):
      """
      This program finds the reverse of the sequence entered. 
      """
      #first we initialize the string variable which will contain our reversed string
      reversed_sequence = ''
      #next we initialize our loop variable to the value of the last index of 'sequence'
      i=len(sequence)-1
      #we use a while loop, which continues till i is greater than or equal to zero 
      while i>=0:
          #we concatenate each letter from the end of the sequence entered to form a new string which has the order reversed
          reversed_sequence = reversed_sequence+sequence[i]
          #in each iteration we decrease the value of the variable i to maintain the loop condition
          i=i-1

      #finally, exit from the function and return the reversed sequence    
      return reversed_sequence
#+end_src

#+RESULTS:
***** Testing the =sequence_reverse()= function 
#+begin_src python :session gdspyt :results output  
print(sequence_reverse(test_sequence))
#+end_src

#+RESULTS:
: CTGCTGGCTGGCGCGCCGCCAGCGCTTCCGCGAGCCGCAGCGGGGCCTCTTTCAGGTCTAGAAGTGCGACTGGAGCCCGCCGCTGATACCGGCCGCGAGCTGCGGCTGCAGCCTGATGCACCAGCTTCGGCGGGTGCACAGGCGGCGCATGGAGCGCCGGCCGGTAGAGCCGGGGCAGTTCTGCTAGACCTGCGCGCTCCTGCTAGACGCGCCGCCGATAATGGCGGGCTACCACGACGTAGCGCAGCTGTAGCCGCACCTGCCGTCGCCGCGGCACGCGCTGACCGTCGTGCACCAGCAGCCGGTCAGACACGACTTCCCGAGCGGCGAGCTCGCGTGCTGCTACGAGTTCGCGCCGTGGCTAGGCTCGGACTGGCTTCCGCACTGCTTGTCGGGCATGCCGAAGGGCTACGTCCATAGCCAAGTAGTCTGGCTCCGGCTGCACGGCCAGGTCTGCACCGCGAGCCCGCCGTTGAGCGTATGCCGCAAGCACTACCTTTGCGACCAGCTGCTCGAGCGCGTGAGCCGCGCCGTCCTAGGCCAGCGGATGGCCTACTGCGCCGACCGGCCGGGGCTCGTGCGGCGCGTAGCCGTCCGCGAGCGCGACCGGCAGCTGTTCAGGCCGATGCCGCGCGCGTGCGACGGCCGGCCCGTGCGCACCCCGCAGCGCTACGTGCTTTGCCGGCCGAGCCAGCAGCGCATGCACTGCCTTCACAGCTAGCTTCGCGTTGTTGGCGCGCACGTAGCGCACTGCCGGCCGCACATACGCCCGGCGTAGCAGTTGGGCTGGCCGCGCGTTCGCGTCTAGGTCCCGCCGCGCGACAAGCCAGAGCGCTGCTGCTTCGGGCCGAAGCGCTAGCTGCAGCTGGTACCGCGCCAGGCGTTGCGGCCAAAGCGGCTGATAAGCGGCTATGCGTACGTCCTTCGCGGCGGCCACCTACAGAAGAAGCACGGCAGCCTGCGGGTCGGCTGGCCCAACTCGCTGCGGCCGCACGGCGGCTAGCGCGGCCGCCACCGGTTGCCACGCAAGCACGACTGGCCGCTCGCCCACGTACGCAACGGCAAGGGGGGCTACGACCAGCGCAGCTGGCGGGGGCACTACGGCCGCCGGGGGCGCTGCCGCCGGCTGCTCCTAGGCATGCCGTTGGACGGCCGGCCGCCGACGGCCGACGGCGTGTTCCAGTTCGGA

**** Complement of a sequence
***** The =dna_complement()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  #this function returns the complement of a DNA sequence entered, NOT the reverse complement
  def dna_complement(sequence):
      """
      This function returns the complementary sequence of a DNA sequence entered.

      """
      #first we define a dictionary containing all the bases and their complements, even in lowecase
      bases_dict = {"A":"T", "a":"t", "C":"G", "c":"g", "G":"C", "g":"c", "T":"A", "t":"a", "N":"N", "n":"n"}

      #we initialize a string variable to store the complementary sequence
      complement = ''

      #next we loop over our sequence and make a new complementary string
      for i in sequence:
          complement = complement + bases_dict[i]

      #finally, return the complement sequence and exit from the function
      return complement
#+end_src

#+RESULTS:

***** Testing the =dna_complement()= function
#+begin_src python :session gdspyt :results output  
print(dna_complement(test_sequence))
#+end_src

#+RESULTS:
: TCCGAACTGGAACACGCCGTCGGCCGTCGGCGGCCGGCCGTCCAACGGCATGCCTAGGAGCAGCCGGCGGCAGCGCCCCCGGCGGCCGTAGTGCCCCCGCCAGCTGCGCTGGTCGTAGCCCCCCTTGCCGTTGCGTACGTGGGCGAGCGGCCAGTCGTGCTTGCGTGGCAACCGGTGGCGGCCGCGCTAGCCGCCGTGCGGCCGCAGCGAGTTGGGCCAGCCGACCCGCAGGCTGCCGTGCTTCTTCTGTAGGTGGCCGCCGCGAAGGACGTACGCATAGCCGCTTATCAGCCGCTTTGGCCGCAACGCCTGGCGCGGTACCAGCTGCAGCTAGCGCTTCGGCCCGAAGCAGCAGCGCTCTGGCTTGTCGCGCGGCGGGACCTAGACGCGAACGCGCGGCCAGCCCAACTGCTACGCCGGGCGTATGTGCGGCCGGCAGTGCGCTACGTGCGCGCCAACAACGCGAAGCTAGCTGTGAAGGCAGTGCATGCGCTGCTGGCTCGGCCGGCAAAGCACGTAGCGCTGCGGGGTGCGCACGGGCCGGCCGTCGCACGCGCGCGGCATCGGCCTGAACAGCTGCCGGTCGCGCTCGCGGACGGCTACGCGCCGCACGAGCCCCGGCCGGTCGGCGCAGTAGGCCATCCGCTGGCCTAGGACGGCGCGGCTCACGCGCTCGAGCAGCTGGTCGCAAAGGTAGTGCTTGCGGCATACGCTCAACGGCGGGCTCGCGGTGCAGACCTGGCCGTGCAGCCGGAGCCAGACTACTTGGCTATGGACGTAGCCCTTCGGCATGCCCGACAAGCAGTGCGGAAGCCAGTCCGAGCCTAGCCACGGCGCGAACTCGTAGCAGCACGCGAGCTCGCCGCTCGGGAAGTCGTGTCTGACCGGCTGCTGGTGCACGACGGTCAGCGCGTGCCGCGGCGACGGCAGGTGCGGCTACAGCTGCGCTACGTCGTGGTAGCCCGCCATTATCGGCGGCGCGTCTAGCAGGAGCGCGCAGGTCTAGCAGAACTGCCCCGGCTCTACCGGCCGGCGCTCCATGCGCCGCCTGTGCACCCGCCGAAGCTGGTGCATCAGGCTGCAGCCGCAGCTCGCGGCCGGTATCAGCGGCGGGCTCCAGTCGCACTTCTAGACCTGAAAGAGGCCCCGCTGCGGCTCGCGGAAGCGCTGGCGGCGCGCCAGCCAGCAG

**** Reverse complement of a sequence
***** The =reverse_complement()= function 
#+begin_src python :session gdspyt :tangle ./temp.py
  #a simple function which calls the reverse string and sequence complement functions to calculate the reverse complements
  def reverse_complement(sequence):
      return(dna_complement(sequence_reverse(sequence)))
    
#+end_src

#+RESULTS:
***** Testing the =reverse_complement()= function
#+begin_src python :session gdspyt :results output
print(reverse_complement(test_sequence))
#+end_src

#+RESULTS:
: GACGACCGACCGCGCGGCGGTCGCGAAGGCGCTCGGCGTCGCCCCGGAGAAAGTCCAGATCTTCACGCTGACCTCGGGCGGCGACTATGGCCGGCGCTCGACGCCGACGTCGGACTACGTGGTCGAAGCCGCCCACGTGTCCGCCGCGTACCTCGCGGCCGGCCATCTCGGCCCCGTCAAGACGATCTGGACGCGCGAGGACGATCTGCGCGGCGGCTATTACCGCCCGATGGTGCTGCATCGCGTCGACATCGGCGTGGACGGCAGCGGCGCCGTGCGCGACTGGCAGCACGTGGTCGTCGGCCAGTCTGTGCTGAAGGGCTCGCCGCTCGAGCGCACGACGATGCTCAAGCGCGGCACCGATCCGAGCCTGACCGAAGGCGTGACGAACAGCCCGTACGGCTTCCCGATGCAGGTATCGGTTCATCAGACCGAGGCCGACGTGCCGGTCCAGACGTGGCGCTCGGGCGGCAACTCGCATACGGCGTTCGTGATGGAAACGCTGGTCGACGAGCTCGCGCACTCGGCGCGGCAGGATCCGGTCGCCTACCGGATGACGCGGCTGGCCGGCCCCGAGCACGCCGCGCATCGGCAGGCGCTCGCGCTGGCCGTCGACAAGTCCGGCTACGGCGCGCGCACGCTGCCGGCCGGGCACGCGTGGGGCGTCGCGATGCACGAAACGGCCGGCTCGGTCGTCGCGTACGTGACGGAAGTGTCGATCGAAGCGCAACAACCGCGCGTGCATCGCGTGACGGCCGGCGTGTATGCGGGCCGCATCGTCAACCCGACCGGCGCGCAAGCGCAGATCCAGGGCGGCGCGCTGTTCGGTCTCGCGACGACGAAGCCCGGCTTCGCGATCGACGTCGACCATGGCGCGGTCCGCAACGCCGGTTTCGCCGACTATTCGCCGATACGCATGCAGGAAGCGCCGCCGGTGGATGTCTTCTTCGTGCCGTCGGACGCCCAGCCGACCGGGTTGAGCGACGCCGGCGTGCCGCCGATCGCGCCGGCGGTGGCCAACGGTGCGTTCGTGCTGACCGGCGAGCGGGTGCATGCGTTGCCGTTCCCCCCGATGCTGGTCGCGTCGACCGCCCCCGTGATGCCGGCGGCCCCCGCGACGGCGGCCGACGAGGATCCGTACGGCAACCTGCCGGCCGGCGGCTGCCGGCTGCCGCACAAGGTCAAGCCT

*** The =frame_extract()= function
#+begin_src python :session gdspyt :tangle ./temp.py 
  def frame_extract(sequence):
      """This function extracts all the 6 ORFs from a given sequence."""

      #initializing the dictionary which will store all the sequences of all the frames 
      frame_dictionary = {}

      #this variable stores the frame numbers 
      frame_no = 1

      #loop extracting frames 1, 2 and 3
      for i in range(3):
          frame_name = "Frame" + str(frame_no)
          frame_dictionary[frame_name] = sequence[i:]
          frame_no = frame_no + 1

      # print(frame_no)

      sequence_reverse_complement = reverse_complement(sequence)

      #loop extracting frames 4, 5, and 6
      for i in range(3):
          frame_name = "Frame" + str(frame_no)
          frame_dictionary[frame_name] = sequence_reverse_complement[i:]
          frame_no = frame_no + 1

      # print(frame_no)

      return(frame_dictionary)
#+end_src

#+RESULTS:

*** Testing the =frame_extract()= function
#+begin_src python :session gdspyt :tangle no
  frm_dic = frame_extract(test_sequence)
  for keys, items in frm_dic.items():
      print(keys, "\n", items, "\n")
#+end_src

#+RESULTS:
: None

** Finding all ORFs in a sequence
To find all the ORFs in a sequence, we simply pass a sequence to a function which will call  =frame_extract()= to get a dictionary of frames. Another loop will pass the entries of this frame dictionary to =frame_orfs()= function, to get all the ORFs in the frame. These will be stored in another dictionary and returned.

*** The =sequence_orfs()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  def sequence_orfs(sequence):
      """This function finds and returns all the ORFs in all frames of a sequence."""
      #initializing the dictionary to store all the frame information of the sequence 
      sequence_orfs_dictionary = {}

      #calling the frame_extract() to find all the frames and store it in frames_dictionary variable 
      frames_dictionary = frame_extract(sequence)

      #this loop goes through all the frames in the dictionary, calls the frame_orfs() function for each frame and stores the output in frames_dictionary.    
      for frame, frame_sequence in frames_dictionary.items():
          sequence_orfs_dictionary[frame] = frame_orfs(frame_sequence)

      #for frame 5, 6, and 7, which are the reverse complement frames, we need to alter the start and stop positions of the frame, so that they are with respect to the forward sequence

      reverse_frames_tuple = ("Frame4", "Frame5", "Frame6")

      #calculating the length of the sequence
      seqlen = len(sequence)

      # now altering the start and stop positions 
      for frame, ORF_dict in sequence_orfs_dictionary.items():
          if frame in reverse_frames_tuple:
              for orfs, info in ORF_dict.items():
                  info[1] = seqlen - info[1]
                  info[2] = seqlen - info[2]

      return sequence_orfs_dictionary
#+end_src

*** Testing the =sequence_orfs()= function
#+begin_src python :session gdspyt :tangle no
  print(sequence_orfs(test_sequence))
#+end_src
** Printing all ORFs in a sequence 
Now we take the have to print the output from the =sequence_orfs()= function
***  Function =print_sequence_orfs()= 
#+begin_src python :session gdspyt :tangle ./temp.py
  def print_sequence_orfs(sequence):
      """This function prints the ORF information of a sequence in a presentable format."""

      seq_orf_info = sequence_orfs(sequence)

      for frame, frame_dict in seq_orf_info.items():
          print("** _ _ _ _ _ _", frame, "_ _ _ _ _ _")
          print("Retrieving", len(frame_dict), "sequences in", frame, "...")
          for orf, orf_dict in frame_dict.items():
              print("***", orf, "\n", orf_dict[0][0], orf_dict[0][1], "...", orf_dict[0][-2], orf_dict[0][-1])
              print(" ", orf_dict[1], "           ", orf_dict[2])

      return 0
#+end_src
*** Testing  =print_sequence_orfs()= 
#+begin_src python :session gdspyt :tangle no
  print_sequence_orfs(test_sequence)
#+end_src
** Comparing and printing the longest ORFs of a sequence 
Now we compare all the ORFs in a given sequence and print them. The function will obtain the sequence dictionary from the =sequence_orfs()= function and return the following information.

#+begin_src python
  longest_orf_length
  longest_orf_dictionary = {frame_no: {orfn1:[start_pos, end_pos], orfn2:[start_pos, end_pos],...}}
  shortest_orf_length 
  shortest_orf_dictionary = {frame_no_orf_no:[start_pos, end_pos], frame_no_orf_no:[start_pos, end_pos],...}
#+end_src
*** The =compare_seq_orfs()= function 
#+begin_src python :session gdspyt :tangle ./temp.py 
  def compare_seq_orfs(sequence):
      """This function compares all the ORFs in a sequence."""

      #getting the ORF information of the sequences 
      seq_orf_info = sequence_orfs(sequence)

      #a dictionary to store the lengths of all the ORFs defined in seq_orf_info
      seq_orf_len_dict = {}

      #this loop builds the seq_orf_len_dict as well as finds the maximum length
      max_len = 0
      for frame, frame_dict in seq_orf_info.items():
          seq_orf_len_dict[frame] = {}
          for orf, orf_list in frame_dict.items():
              #we subtract the starting and ending positions of the ORFs
              orf_len = abs(orf_list[1] - orf_list[2])
              #initialize a new dictionary inside of seq_orf_len_dict, corresponding to a key, frame
              seq_orf_len_dict[frame][orf] = orf_len
              if orf_len >= max_len:
                  max_len = orf_len

      #now we find the minimum length 
      min_len = max_len 
      for frame, frame_dict in seq_orf_len_dict.items():
          for orf, orf_len in frame_dict.items():
              if orf_len <= min_len:
                  min_len = orf_len


      #since there can be more than one sequences with the maximum or minimum lengths, we initialize a dictionary which will store all frames and ORFs corresponting to the maximum and minimum lengths 
      max_len_dict = {}
      min_len_dict = {}
      for frame, frame_dict in seq_orf_len_dict.items():
          for orf, orf_len in frame_dict.items():
              if orf_len == max_len:
                  max_len_dict[frame] = {}
                  max_len_dict[frame][orf] = [seq_orf_info[frame][orf][1], seq_orf_info[frame][orf][2]]
              elif orf_len == min_len:
                  min_len_dict[frame] = {}
                  min_len_dict[frame][orf] = [seq_orf_info[frame][orf][1], seq_orf_info[frame][orf][2]]

      return (max_len, max_len_dict, min_len, min_len_dict, seq_orf_len_dict)
#+end_src
*** Testing =compare_seq_orfs()= function

#+begin_src python :session gdspyt :tangle no 
  comparison_tuple = compare_seq_orfs(test_sequence)
  print(comparison_tuple)
#+end_src
** Printing ORF information of all sequences in a file
*** The =print_orfs_of_file()= function 
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
  #first we got to import the functions which store sequence lengths of a file in the form of a dictionary.
  from temp import * 

  def print_orfs_of_file(fasta_dict):
      """This function takes as input a dictionary containing all sequences in a file in the format "identifier:sequence" and prints all the ORFs of all reading frames of all sequences of a file."""

      for identifier, sequence_orf_info in fasta_dict.items():
          print("* ++++++", identifier, "++++++")
          print_sequence_orfs(sequence_orf_info)
#+end_src

*** Testing =print_orfs_of_file()= function
#+begin_src python :tangle no 
print_orfs_of_file(fast_dict)
#+end_src

** Printing the longest and shortest ORFs among all sequences in a file
Till now we can compare all the ORFs in a particular sequence with the =compare_seq_orfs()= function, which returns a tuple of type =(max_len, max_len_dict, min_len, min_len_dict)=.

Now, to compare ORFs of all sequences in a file, the =file_ORF_compare_lengths()= function must first store the maximum and minimum ORF lengths of all the sequences in a dictionary of type: 

#+begin_src python
  file_orf_len_dict = {
      sequence_id_1: (
          max_len, max_len_dict = {frame_a1:
                                   {ORF_a1: [start_pos, end_pos],
                                    .
                                    .
                                    .,
                                    ORF_an: [start_pos, end_pos]},
                                   .
                                   .
                                   .
                                   frame_an: [ORF_a1, ..., ORF_an]},
          min_len, min_len_dict = {frame_a1:
                                   {ORF_a1: [start_pos, end_pos],
                                    .
                                    .
                                    .,
                                    ORF_an: [start_pos, end_pos]}}),
      .
      .
      .,
      sequence_id_n: (
          max_len, max_len_dict = {frame_a1:
                                   {ORF_a1: [start_pos, end_pos],
                                    .
                                    .
                                    .,
                                    ORF_an: [start_pos, end_pos]},
                                   .
                                   .
                                   .
                                   frame_an: [ORF_a1, ..., ORF_an]},
          min_len, min_len_dict = {frame_a1:
                                   {ORF_a1: [start_pos, end_pos],
                                    .
                                    .
                                    .,
                                    ORF_an: [start_pos, end_pos]}})}
    


#+end_src

Then there will be a comparison between the sequences, which has the longest and shortest ORFs. The =file_ORF_compare_lengths()= function will return the lengths of the longest and shortest ORFs in the file.

The next function =get_all_ORFs_of_length(x)= will fetch all the ORFs in a file corresponding to a given length =x= and return a dictionary of type:

#+begin_src python
  file_ORFs_len_x_dict =  {sequence_a1:
                           {frame_b1:
                            {orf_c1: [start, end], ..., orf_cn: [start, end]},
                            .
                            .
                            .,
                            frame_bn:
                            {orf_c1: [start, end], ..., orf_cn: [start, end]}},
                           .
                           .
                           .,
                           sequence_an:
                           {frame_b1:
                            {orf_c1: [start, end], ..., orf_cn: [start, end]},
                            .
                            .
                            .,
                            frame_bn:
                            {orf_c1: [start, end], ..., orf_cn: [start, end]}}}
#+end_src

A final function, =print_longest_shortest_ORFs(fasta_dict)= will process the longest and shortest ORFs returned by the =file_ORF_compare_lengths()= into the =get_all_ORFs_of_length()= function to print all longest and shortest ORFs in a file. 

*** Finding the longest and shortest lengths of all ORFs in a file 

**** The =file_ORF_compare_lengths()= function
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py  
  def file_ORF_compare_lengths(fasta_dict):
   """This function compares the maximum and minimum lengths of all sequences in a file and returns the lengths of the longest and shortest ORF in the file."""
   #initializing the dictionary which will store the ORF lengths of all the sequences 
   file_ORF_len_dict = {}

   #building the file_ORF_len_dict dictionary 
   for identifier, sequence in fasta_dict.items():
    file_ORF_len_dict[identifier] = compare_seq_orfs(sequence)

   #now we will go over the entries of the dictionary and get the values of the maximum ORF
   max_len_file = 0
   for identifier, sequence_info in file_ORF_len_dict.items():
    #the first entry in the tuple returned by compare_seq_ORFs contains the maximum length of the sequence 
    if sequence_info[0] > max_len_file:
     max_len_file = sequence_info[0]

   #getting the value of the minimum length of the ORF
   min_len_file = max_len_file
   for identifier, sequence_info in file_ORF_len_dict.items():
    #the third entry in the tuple returned by compare_seq_ORFs contains the minimum length of the sequence 
    if sequence_info[2] < min_len_file:
     min_len_file = sequence_info[2]

   return (max_len_file, min_len_file) 
#+end_src

**** Testing =file_ORF_compare_lengths()= function
#+begin_src python :session gdspyt :tangle no
  print(file_ORF_compare_lengths(fast_dict))
#+end_src

*** Getting all ORFs in  a file of length x 
**** The =get_all_ORFs_of_length()= function
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
  def get_all_ORFs_of_length(fasta_dict, x):
      """This function gets all ORFs of length x from a file whose sequence information has been stored in fasta_dict"""

      all_ORFs_dict = {}

      file_ORF_lengths_dict = {}
      for identifier, sequence in fasta_dict.items():
          seq_info = compare_seq_orfs(sequence)
          file_ORF_lengths_dict[identifier] = seq_info[4]


      #initializing the list containing ORF of length x
      dict_file_orfs_length_x = []
      for identifier, identifier_info in file_ORF_lengths_dict.items():
          for frame, frame_ORF_info in identifier_info.items():
              for ORF, length in frame_ORF_info.items():
                  if length == x:
                      ORF_coordinates = (identifier, frame, ORF)
                      dict_file_orfs_length_x.append(ORF_coordinates)
                
                
      return dict_file_orfs_length_x

#+end_src

**** Test =get_all_ORFs_of_length()= function
#+begin_src python :session gdspyt :tangle no
print(get_all_ORFs_of_length(fast_dict, 5))
#+end_src

*** Printing all the longest and shortest ORFs in a file 
**** The =print_longest_shortest_ORFs(fasta_dict)= function
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
  def print_longest_shortest_ORFs(fasta_dict):
      """This function prints all the longest and shortest ORFs, considering all the frames of all sequences in a file """

      #first we call the file_ORF_compare_lengths() to store the maximum and minimum ORF lengths of the file in a tuple returned by the function 
      max_min_tuple = file_ORF_compare_lengths(fasta_dict)
      #then we store the all the ORFs having the maximum and minimum lengths
      max_ORF_list = get_all_ORFs_of_length(fasta_dict, max_min_tuple[0])
      min_ORF_list = get_all_ORFs_of_length(fasta_dict, max_min_tuple[1])

      #Finally to print them out in a nicely formatted way 
      print("\n\nThe ORF(s) with the maximum lengths of", max_min_tuple[0], "are:")
      print("\nIdentifier \t\t\t Frame \t\t ORF")
      print("__________ \t\t\t _____ \t\t ___")
      for i in range(len(max_ORF_list)):
          print(max_ORF_list[i][0], "\t", max_ORF_list[i][1], "\t", max_ORF_list[i][2])
      print("\n\nThe ORF(s) with the minimum lengths of", max_min_tuple[1], "are:")
      print("\nIdentifier \t\t\t Frame \t\t ORF")
      print("__________ \t\t\t _____ \t\t ___")
      for i in range(len(min_ORF_list)):
          print(min_ORF_list[i][0], "\t", min_ORF_list[i][1], "\t", min_ORF_list[i][2])

      return 0 
#+end_src

**** Test =print_longest_shortest_ORFs(fasta_dict)= function
#+begin_src python :session gdspyt :tangle no
print_longest_shortest_ORFs(fast_dict)
#+end_src


* Mapping Repeats in the File

** Question
(4) A repeat is a substring of a DNA sequence that occurs in multiple copies (more than one) somewhere in the sequence. Although repeats can occur on both the forward and reverse strands of the DNA sequence, we will only consider repeats on the forward strand here. Also we will allow repeats to overlap themselves. For example, the sequence ACACA contains two copies of the sequence ACA - once at position 1 (index 0 in Python), and once at position 3.

Given a length n, your program should be able to identify all repeats of length n in all sequences in the FASTA file.

Your program should also determine how many times each repeat occurs in the file, and which is the most frequent repeat of a given length.

** Our Approach 
The question asks us to find all repeats of length n in a DNA sequence.

1. [ ] In a simplest case, we can define a sliding window of length x which will go over the DNA sequence and find all repeats of length n in that sequence. Additional data stored will be how many times each repeat occurs in the sequence. 
2. [ ] Now we can scale that up to all sequences in the file.
3. [ ] Now we deal on a per-repeat basis - we add the number of occurances of a particular repeat of length x to get the total number of times the repeat occurs in the file. 
4. [ ] Finally we can find the most frequent repeat(s) in the file.


** Finding number of repeats of a given length in a given sequence
*** COMMENT The =repeat_mapper(sequence, length)= function
#+begin_src python :session gdspyt :tangle ./repeats.py
  def repeat_mapper(sequence, repeat_length):
      """This function goes over a sequence and finds all the repeats of length x and their occurances."""

      #we slide a window of 'length' nucleotides from position 1 to 1+length and then 2 to 2+length and so on, to get sequences of 'length' nucleotides.
      #This window will have to stop at end minus 
      i = 0
      while (i < = len(sequence) - repeat_length):
         repeat_candidate = sequence[i:(i + repeat_length)]
         j = 0
         #now we go over the sequence and find substrings matching the repeat sequence
         while (j <= (len(sequence) - repeat_length)):
             test_window = sequence[j:(j + repeat_length)]
             if test_window == repeat_candidate:
                 new_match_pos = j
                 repeat_enquirer = j + 1
                 prev_match_pos = new_match_pos
                 #for the occurance to be considered a repeat, the distance between the position of the present (new occurance) and that of the future occurance should not be greater than the length of the repeat 
                 while((new_match_pos - (prev_match_pos + repeat_length)) <=0):
                     j = j + 1
                     test_window = sequence[j:(j + repeat_length)]
                     if test_window == repeat_candidate:
                         prev_match_pos = new_match_pos
                         new_match_pos = j 
                         repeat_counter = repeat_counter + 1
                       
                       
                   
               
             j = j + 1

          i = i + 1
        
        
#+end_src

#+begin_src python :results output
  s = "AGTCTGCA"
  n = 3
  print(len(s))
  i = 0
  while (i <=len(s) - n):
      print(s[i:i+n])
      i = i + 1
#+end_src

#+RESULTS:
: 8
: AGT
: GTC
: TCT
: CTG
: TGC
: GCA
