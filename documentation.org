#+title:A set of sequence manipulation code
* Reading from a Given FASTA file
(1) How many records are in the file? A record in a FASTA file is defined as a single-line header, followed by lines of sequence data. The header line is distinguished from the sequence data by a greater-than (">") symbol in the first column. The word following the ">" symbol is the identifier of the sequence, and the rest of the line is an optional description of the entry. There should be no space between the ">" and the first letter of the identifier. 

Separate functions for the following tasks are to be written:
1. Accepting a FASTA file as input from the command line [other arguments if necessary will be accepted later by modifying this code]
2. Reading from a FASTA file and putting sequences into a dictionary
3. Using the dictionary to count and return the number of sequences
** Parsing a FASTA File
*** Opening the file 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py
  #!/usr/bin/python3
  #the following code reads from a FASTA file and puts the sequences in a dictionary
  import sys
  def usage():
      print
      """
      The program allows the user to ....

      Basic Usage:

      python3 fastinfo.py <filename.FASTA> [option1] [option2...]

      """
      return 0

  #now we open the file, which is stored in the second position of the sys.argv[] list
  try:
      f = open(sys.argv[1], 'r')
      print("FASTA File found. Processing...")
  except IOError:
      print("The file does not exist! Please recheck the filename.")
      sys.exit()

#+end_src

*** Putting the sequences of the file in a dictionary
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org
  def multi_FASTA_to_dict(FASTA_file_object):
      """
      This function opens a FASTA file and puts the sequences in a dictionary. 
      """
      sequence_dictionary = {}
      for line in FASTA_file_object:
          line = line.rstrip() #removing the trailing newlines from the FASTA file
          #print(line)
          if line[0] == '>':
              #split the header into a list consisting of the sequence identifier and the description 
              header_word_list = line[1:].split() 
              #identifier would be the first word of the header word list
              identifier = header_word_list[0]
              #print(identifier)
              #initializing an empty entry corresponding to the sequence identifier
              sequence_dictionary[identifier] = ""
              #print(sequence_dictionary[identifier])
          else:
              sequence_dictionary[identifier] = sequence_dictionary[identifier]+line #we concatenate the subsequent lines to the entry corresponding to an identifier
              #print(sequence_dictionary[identifier])

      return sequence_dictionary
#+end_src

*** Printing file information 
Now we print the sequence identifiers in the dictionary and the number of entries in the multi-FASTA file. 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org 
  fast_dict = multi_FASTA_to_dict(f)
  print("\nThe following identifiers have been retrieved:")
  for keys in fast_dict:
      print(keys)
      #print(fast_dict[keys]) #prints all sequences, hence commented out
  print("\nThere are a total of", len(fast_dict), "sequences in the file.")
#+end_src

*** Printing length information of sequences
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org 
  from seqlen_compare import *
  seq_len_compare(fast_dict)
#+end_src
*** Example sequence
#+begin_src python :session gdspyt
test_sequence="AGGCTTGACCTTGTGCGGCAGCCGGCAGCCGCCGGCCGGCAGGTTGCCGTACGGATCCTCGTCGGCCGCCGTCGCGGGGGCCGCCGGCATCACGGGGGCGGTCGACGCGACCAGCATCGGGGGGAACGGCAACGCATGCACCCGCTCGCCGGTCAGCACGAACGCACCGTTGGCCACCGCCGGCGCGATCGGCGGCACGCCGGCGTCGCTCAACCCGGTCGGCTGGGCGTCCGACGGCACGAAGAAGACATCCACCGGCGGCGCTTCCTGCATGCGTATCGGCGAATAGTCGGCGAAACCGGCGTTGCGGACCGCGCCATGGTCGACGTCGATCGCGAAGCCGGGCTTCGTCGTCGCGAGACCGAACAGCGCGCCGCCCTGGATCTGCGCTTGCGCGCCGGTCGGGTTGACGATGCGGCCCGCATACACGCCGGCCGTCACGCGATGCACGCGCGGTTGTTGCGCTTCGATCGACACTTCCGTCACGTACGCGACGACCGAGCCGGCCGTTTCGTGCATCGCGACGCCCCACGCGTGCCCGGCCGGCAGCGTGCGCGCGCCGTAGCCGGACTTGTCGACGGCCAGCGCGAGCGCCTGCCGATGCGCGGCGTGCTCGGGGCCGGCCAGCCGCGTCATCCGGTAGGCGACCGGATCCTGCCGCGCCGAGTGCGCGAGCTCGTCGACCAGCGTTTCCATCACGAACGCCGTATGCGAGTTGCCGCCCGAGCGCCACGTCTGGACCGGCACGTCGGCCTCGGTCTGATGAACCGATACCTGCATCGGGAAGCCGTACGGGCTGTTCGTCACGCCTTCGGTCAGGCTCGGATCGGTGCCGCGCTTGAGCATCGTCGTGCGCTCGAGCGGCGAGCCCTTCAGCACAGACTGGCCGACGACCACGTGCTGCCAGTCGCGCACGGCGCCGCTGCCGTCCACGCCGATGTCGACGCGATGCAGCACCATCGGGCGGTAATAGCCGCCGCGCAGATCGTCCTCGCGCGTCCAGATCGTCTTGACGGGGCCGAGATGGCCGGCCGCGAGGTACGCGGCGGACACGTGGGCGGCTTCGACCACGTAGTCCGACGTCGGCGTCGAGCGCCGGCCATAGTCGCCGCCCGAGGTCAGCGTGAAGATCTGGACTTTCTCCGGGGCGACGCCGAGCGCCTTCGCGACCGCCGCGCGGTCGGTCGTC"
#+end_src

* Comparing sequences in the file

** Question 
#+begin_quote
(2) What are the lengths of the sequences in the file? What is the longest sequence and what is the shortest sequence? Is there more than one longest or shortest sequence? What are their identifiers? 
#+end_quote
** Our Approach 
The way to go about this is:
- Find the length of each seqeunce in the dictionary and put this in another dictionary with keys as the identifiers and values as the length. Use this dictionary for comparison.
- Now, find the longest and shortest sequence and print their identifiers and lengths.
** Creating a dictionary storing identifiers and sequence lengths and printing it 
#+begin_src python :tangle ./seqlen_compare.py :comments org :mkdirp 
  def seq_len_compare(seq_dict):
      """This function compares the length of DNA sequences in a dictionary
      """

      """first, we create a new sequence dictionary which stores lengths against identifiers
      """
      seq_len_dict = {}
      for keys,values in seq_dict.items():
          seq_len_dict[keys] = len(values)

      #for testing     
      # for keys,values in seq_len_dict.items():
      #     print(keys,values)


      """
      Now we compare the lengths of sequences in the dictionary.
      """

      #1. Maximum Length

      #first we initialize the maximum sequence length to 0
      max = 0
      #next we initialize a variable to store the identifier corresponding to the maximum sequence length
      max_identifier = ''
      #now we create a list which holds all identifiers which have the maximum value
      max_list = []
      for keys,values in seq_len_dict.items():
          if values>max:
              max = values
              max_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the maximum length
      for keys,values in seq_len_dict.items():
          if values==max:
              max_list.append(keys)

      #2. Minimum Length 
      #first we initialize the minimum sequence length to the maximum value obtained in the previous section
      min = max 
      #next we initialize a variable to store the identifier corresponding to the minimum sequence length
      min_identifier = ''
      #now we create a list which holds all identifiers which have the minimum value
      min_list = []
      for keys,values in seq_len_dict.items():
          if values<min:
              min = values
              min_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the minimum length
      for keys,values in seq_len_dict.items():
          if values==min:
              min_list.append(keys)

      """
      Now we print out the values obtained along with their identifiers.
      """
      #1. Print Maximum Length(s)
      print("\nThe following", len(max_list),  "sequence(s) has/have the maximum length of", max, '.')
      for x in range(len(max_list)):
          #print the identifiers in the max_list
          print("\n", max_list[x])

      #2. Print Minimum Length(s)
      print("\nThe following", len(min_list), "sequence(s) has/have the minimum length of", min,'.')
      for x in range(len(min_list)):
          #print the identifiers in the min_list
          print("\n", min_list[x])

      #to exit from the function
      return 0
#+end_src

* Identification and Mapping of Open Reading Frames (ORFs)
** Question 
#+begin_quote
(3) In molecular biology, a reading frame is a way of dividing the DNA sequence of nucleotides into a set of consecutive, non-overlapping triplets (or codons). Depending on where we start, there are six possible reading frames: three in the forward (5' to 3') direction and three in the reverse (3' to 5'). For instance, the three possible forward reading frames for the sequence AGGTGACACCGCAAGCCTTATATTAGC are: 

AGG TGA CAC CGC AAG CCT TAT ATT AGC

A GGT GAC ACC GCA AGC CTT ATA TTA GC

AG GTG ACA CCG CAA GCC TTA TAT TAG C 

These are called reading frames 1, 2, and 3 respectively. An open reading frame (ORF) is the part of a reading frame that has the potential to encode a protein. It starts with a start codon (ATG), and ends with a stop codon (TAA, TAG or TGA). For instance, ATGAAATAG is an ORF of length 9.

Given an input reading frame on the forward strand (1, 2, or 3) your program should be able to:
1. identify all ORFs present in each sequence of the FASTA file, and answer
2. what is the length of the longest ORF in the file?
3. What is the identifier of the sequence containing the longest ORF?
4. For a given sequence identifier, what is the longest ORF contained in the sequence represented by that identifier?
5. What is the starting position of the longest ORF in the sequence that contains it? The position should indicate the character number in the sequence. For instance, the following ORF in reading frame 1:

>sequence1

ATGCCCTAG

starts at position 1.

Note that because the following sequence:

>sequence2

ATGAAAAAA

does not have any stop codon in reading frame 1, we do not consider it to be an ORF in reading frame 1. 
#+end_quote

** Our Approach 
*** How we define ORFs?
Open Reading Frames are substrings of DNA sequence strings which start with a start codon ATG and end with a stop codon, TAA, TAG or TGA.

Now, a given sequence will have 6 reading frames. Given a sequence, its easy to understand the first 3: we start accepting codons in multiples of 3 from the first position, the second and the third. 

What about the frames 4, 5 and 6? For them, we take the reverse strand, that is, the reverse complement of our sequence and take ORFs in it, as we had done for the forward strand.

The problem with the reverse strand is, we also have to map the starting and ending positions of the ORF, if any.

For this, when we get the starting position of the ORF in a reverse complement string, we use the subtract that position from the total length of the forward sequence. That gives us the starting position of the orf in the reverse direction, in the forward string itself.
** Finding reverse complement of sequences
*** Revese of a Sequence
#+begin_src python :session gdspyt
  #This is a simple function to reverse a string
  def sequence_reverse(sequence):
      """
      This program finds the reverse of the sequence entered. 
      """
      #first we initialize the string variable which will contain our reversed string
      reversed_sequence = ''
      #next we initialize our loop variable to the value of the last index of 'sequence'
      i=len(sequence)-1
      #we use a while loop, which continues till i is greater than or equal to zero 
      while i>=0:
          #we concatenate each letter from the end of the sequence entered to form a new string which has the order reversed
          reversed_sequence = reversed_sequence+sequence[i]
          #in each iteration we decrease the value of the variable i to maintain the loop condition
          i=i-1

      #finally, exit from the function and return the reversed sequence    
      return reversed_sequence
#+end_src

Testing the above:
#+begin_src python :session gdspyt :results output  
print(sequence_reverse(test_sequence))
#+end_src

*** Complement of a sequence
#+begin_src python :session gdspyt :results output
  #this function returns the complement of a DNA sequence entered, NOT the reverse complement
  def dna_complement(sequence):
      """
      This function returns the complementary sequence of a DNA sequence entered.

      """
      #first we define a dictionary containing all the bases and their complements, even in lowecase
      bases_dict = {"A":"T", "a":"t", "C":"G", "c":"g", "G":"C", "g":"c", "T":"A", "t":"a", "N":"N", "n":"n"}

      #we initialize a string variable to store the complementary sequence
      complement = ''

      #next we loop over our sequence and make a new complementary string
      for i in sequence:
          complement = complement + bases_dict[i]

      #finally, return the complement sequence and exit from the function
      return complement
#+end_src

Testing the above function
#+begin_src python :session gdspyt :results output  
print(dna_complement(test_sequence))
#+end_src

*** Reverse complement of a sequence
#+begin_src python :session gdspyt
  #a simple function which calls the reverse string and sequence complement functions to calculate the reverse complements
  def reverse_complement(sequence):
      return(dna_complement(sequence_reverse(sequence)))
    
#+end_src

Testing the above function
#+begin_src python :session gdspyt :results output
print(reverse_complement(test_sequence))
#+end_src

** Finding all ORFs in a sequence
Orf storage scheme:
- A dictionary containing all sequence identifers as keys. For each identifier:
  - A nested dictionary containing information about 6 reading frames. For each reading frame: 
    - A list containing 3 things:
      1. A nested list containing the codons of the ORF, if found, from the start through the stop condons
      2. Start position of the ORF, if found
      3. Stop position of the ORF, if found 
#+begin_src python
  orf_dictionary = {
      identifier_1:
      frame_dictionary_1{
          frame_1:
          frame_1_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame],
          frame_2:
          frame_2_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame],
          .
          .
          .,
          frame_6:
          frame_6_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame]},

      identifier_2:
      frame_dictionary_2{
          frame_1:
          frame_1_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame],
          frame_2:
          frame_2_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame],
          .
          .
          .,
          frame_6:
          frame_6_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame]},
      .
      .
      .,
      identifier_n:
      frame_dictionary_n{
          frame_1:
          frame_1_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame],
          frame_2:
          frame_2_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame],
          .
          .
          .,
          frame_6:
          frame_6_list[
              orf_codon_list["startcodon", ..., "stopcodon"],
              start_index_in_frame,
              stop_index_in_frame]}}
#+end_src

#+begin_src python
  #in this function we find all ORFs in a sequence, that is, sequences which start with ATG and end with any of the stop codons TAA, TAG and TGA
  def ORF_find(seq_dictionary):
      """
      This function accepts a sequence dictionary created from identifier:sequence pairs from a multi-FASTA file and returns another sequence dictionary containing identifier:ORF lists.

      """

      """Initializing some necessicities""" 

      #the master dictionary containing all the ORFs from all reading frames along with their positions in each sequence
      orf_dictionary = {}
    
      #Variable to store the reverse complement 
      reverse_complement = ''

      #Tuple containing our stop codons
      stop_codon_tuple = ("TAA", "TAG", "TGA")

      #the start codon
      start_codon = "ATG"

      #initializing the start and stop codon position variables to null values 
      start_index_in_frame = None
      stop_index_in_frame = None

      """Now we enter the loop to check for our coding sequences."""
      for identifiers, sequences in seq_dictionary.items():
          reverse_complement = reverse_complement(values)
          #start going through frames 1, 2 and 3
          codon = ""
          frame_dictionary = {}
          i = 0
          while i<3:
              for j in range(i, (len(sequences) - (i + 3))):
                  codon = values[j:(j + 3)]
                  if codon == start_codon:
                      start_index_in_frame = j
                  if codon in stop_codon_tuple:
                      stop_index_in_frame = j
                  #skipping 3 codons and re-entering the loop     
                  j = j + 3

              frame_list = []
              orf_codon_list = []
              #Now check if the reading frame actually contains an ORF
              if (start_index_in_frame != None && stop_index_in_frame != None):

                  #continue from the position where start_codon was encountered 
                  j = start_index_in_frame
                
                  #stop at stop codon's position 
                  while (j < stop_index_in_frame):
                      #build the codon list in the ORF 
                      orf_codon_list.append(sequence[j:j+3])
                      j + 3
                  #building the frame information list
                  frame_list.append(orf_codon_list)
                  frame_list.append(start_index_in_frame)
                  frame_list.append(stop_index_in_frame)
                
                  frame_dictionary["Frame_" + str(i+1)] = frame_list

          orf_dictionary[identifiers] = frame_dictionary






#+end_src


Test for the None assignment and condition

#+begin_src python :results output
  test = None
  if test==None:
      print("The value of the variable is", test)
  if test != None:
      print("LOL")
#+end_src

#+RESULTS:
: The value of the variable is None

Test for slicing behavior

#+begin_src python :results output
  string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  #the above string contains only 36 characters, thus the last index should be 35.
  #thus printing from 0 index through 36 should give back the string from index 0 through 35, which is 0 to 36-1
  print(string[0:36])
#+end_src

#+RESULTS:
: ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
