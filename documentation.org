#+title:A set of sequence manipulation code

* Roadmap

** TODO Create the UI 

** DONE Include start and end positions in the =print_longest_shortest_ORFs= output
CLOSED: [2022-06-29 Wed 20:26]

** TODO Implement Longest ORF in a given frame 

** TODO Implement longest ORF in a given identifierxs
** DONE Fix the ORF question to find ORFs as described in  [[file:new_information.org][new_information.org]].
CLOSED: [2022-06-29 Wed 10:12]
** DONE Test and debug repeats 
CLOSED: [2022-06-29 Wed 00:55]
** DONE Find repeats 
CLOSED: [2022-06-27 Mon 12:34]
* Table of Contents                                                 :toc@2:
- [[#roadmap][Roadmap]]
  - [[#create-the-ui][Create the UI]]
  - [[#include-start-and-end-positions-in-the-print_longest_shortest_orfs-output][Include start and end positions in the =print_longest_shortest_ORFs= output]]
  - [[#implement-longest-orf-in-a-given-frame][Implement Longest ORF in a given frame]]
  - [[#implement-longest-orf-in-a-given-identifierxs][Implement longest ORF in a given identifierxs]]
  - [[#fix-the-orf-question-to-find-orfs-as-described-in--new_informationorg][Fix the ORF question to find ORFs as described in  new_information.org.]]
  - [[#test-and-debug-repeats][Test and debug repeats]]
  - [[#find-repeats][Find repeats]]
- [[#reading-and-comparing-sequences-in-a-given-fasta-file][Reading and comparing sequences in a Given FASTA file]]
  - [[#example-sequence][Example sequence]]
  - [[#question][Question]]
  - [[#comparing-sequences-in-the-file][Comparing sequences in the file]]
- [[#identification-and-mapping-of-open-reading-frames-orfs][Identification and Mapping of Open Reading Frames (ORFs)]]
  - [[#question-1][Question]]
  - [[#approach][Approach]]
  - [[#finding-all-orfs-in-a-single-frame][Finding all ORFs in a single frame]]
  - [[#finding-all-the-frames-of-a-sequence][Finding all the frames of a sequence]]
  - [[#finding-all-orfs-in-a-sequence][Finding all ORFs in a sequence]]
  - [[#printing-all-orfs-in-a-sequence][Printing all ORFs in a sequence]]
  - [[#print-all-orfs-in-the-file][Print all ORFs in the file]]
  - [[#comparing-and-printing-the-longest-and-shortest-orfs-of-a-sequence][Comparing and printing the longest and shortest ORFs of a sequence]]
  - [[#printing-the-longest-and-shortest-orfs-among-all-sequences-in-a-file][Printing the longest and shortest ORFs among all sequences in a file]]
  - [[#printing-the-longest-and-shortest-orf-in-the-file-corresponding-to-a-particular-frame-number-fno][Printing the longest and shortest ORF in the file corresponding to a particular frame number 'fno']]
- [[#mapping-repeats-in-the-file][Mapping Repeats in the File]]
  - [[#question-2][Question]]
  - [[#our-approach][Our Approach]]
  - [[#getting-frequency-of-a-given-repeat-in-a-sequence][Getting frequency of a given repeat in a sequence]]
  - [[#getting-the-frequency-of-all-repeat-units-of-length-n-in-a-sequence][Getting the frequency of all repeat units of length n in a sequence]]
  - [[#printing-the-frequency-of-a-given-repeat-in-a-file][Printing the frequency of a given repeat in a file]]
  - [[#getting-the-repeat-information-of-all-unique-repeats-for-all-sequences-of-a-file][Getting the repeat information of all unique repeats for all sequences of a file]]
  - [[#finding-the-most-frequent-repeat-units-of-length-n-in-a-file][Finding the most frequent repeat unit(s) of length 'n' in a file]]
  - [[#printing-repeat-units-of-length-n-with-maximum-frequency-in-the-file][Printing repeat units of length 'n' with maximum frequency in the file]]
- [[#creating-the-ui][Creating the UI]]
  - [[#taking-the-input-and-generating-the-options][Taking the input and generating the options]]
  - [[#broad-file-operations][Broad file operations]]
  - [[#open-reading-frames-operations][Open Reading frames operations]]
  - [[#repeats--operations][Repeats  operations]]

* Reading and comparing sequences in a Given FASTA file
** Example sequence
#+begin_src python :session gdspyt :tangle ./orfs.py
test_sequence="AGGCTTGACCTTGTGCGGCAGCCGGCAGCCGCCGGCCGGCAGGTTGCCGTACGGATCCTCGTCGGCCGCCGTCGCGGGGGCCGCCGGCATCACGGGGGCGGTCGACGCGACCAGCATCGGGGGGAACGGCAACGCATGCACCCGCTCGCCGGTCAGCACGAACGCACCGTTGGCCACCGCCGGCGCGATCGGCGGCACGCCGGCGTCGCTCAACCCGGTCGGCTGGGCGTCCGACGGCACGAAGAAGACATCCACCGGCGGCGCTTCCTGCATGCGTATCGGCGAATAGTCGGCGAAACCGGCGTTGCGGACCGCGCCATGGTCGACGTCGATCGCGAAGCCGGGCTTCGTCGTCGCGAGACCGAACAGCGCGCCGCCCTGGATCTGCGCTTGCGCGCCGGTCGGGTTGACGATGCGGCCCGCATACACGCCGGCCGTCACGCGATGCACGCGCGGTTGTTGCGCTTCGATCGACACTTCCGTCACGTACGCGACGACCGAGCCGGCCGTTTCGTGCATCGCGACGCCCCACGCGTGCCCGGCCGGCAGCGTGCGCGCGCCGTAGCCGGACTTGTCGACGGCCAGCGCGAGCGCCTGCCGATGCGCGGCGTGCTCGGGGCCGGCCAGCCGCGTCATCCGGTAGGCGACCGGATCCTGCCGCGCCGAGTGCGCGAGCTCGTCGACCAGCGTTTCCATCACGAACGCCGTATGCGAGTTGCCGCCCGAGCGCCACGTCTGGACCGGCACGTCGGCCTCGGTCTGATGAACCGATACCTGCATCGGGAAGCCGTACGGGCTGTTCGTCACGCCTTCGGTCAGGCTCGGATCGGTGCCGCGCTTGAGCATCGTCGTGCGCTCGAGCGGCGAGCCCTTCAGCACAGACTGGCCGACGACCACGTGCTGCCAGTCGCGCACGGCGCCGCTGCCGTCCACGCCGATGTCGACGCGATGCAGCACCATCGGGCGGTAATAGCCGCCGCGCAGATCGTCCTCGCGCGTCCAGATCGTCTTGACGGGGCCGAGATGGCCGGCCGCGAGGTACGCGGCGGACACGTGGGCGGCTTCGACCACGTAGTCCGACGTCGGCGTCGAGCGCCGGCCATAGTCGCCGCCCGAGGTCAGCGTGAAGATCTGGACTTTCTCCGGGGCGACGCCGAGCGCCTTCGCGACCGCCGCGCGGTCGGTCGTC"
#+end_src

#+RESULTS:

*** Putting the sequences of the file in a dictionary
#+begin_src python :tangle ./parsefasta.py 
  def multi_FASTA_to_dict(FASTA_file_object):
      """
      This function takes a file object of a FASTA file and puts the sequences in a dictionary. 
      """
      sequence_dictionary = {}
      for line in FASTA_file_object:
          line = line.rstrip() #removing the trailing newlines from the FASTA file
          #print(line)
          if line[0] == '>':
              #split the header into a list consisting of the sequence identifier and the description 
              header_word_list = line[1:].split() 
              #identifier would be the first word of the header word list
              identifier = header_word_list[0]
              #print(identifier)
              #initializing an empty entry corresponding to the sequence identifier
              sequence_dictionary[identifier] = ""
              #print(sequence_dictionary[identifier])
          else:
              sequence_dictionary[identifier] = sequence_dictionary[identifier]+line #we concatenate the subsequent lines to the entry corresponding to an identifier
              #print(sequence_dictionary[identifier])

      return sequence_dictionary
#+end_src

** Question 
(1) How many records are in the file? A record in a FASTA file is defined as a single-line header, followed by lines of sequence data. The header line is distinguished from the sequence data by a greater-than (">") symbol in the first column. The word following the ">" symbol is the identifier of the sequence, and the rest of the line is an optional description of the entry. There should be no space between the ">" and the first letter of the identifier. 

Separate functions for the following tasks are to be written:
1. Accepting a FASTA file as input from the command line [other arguments if necessary will be accepted later by modifying this code]
2. Reading from a FASTA file and putting sequences into a dictionary
3. Using the dictionary to count and return the number of sequences
** Comparing sequences in the file
*** Question 
#+begin_quote
(2) What are the lengths of the sequences in the file? What is the longest sequence and what is the shortest sequence? Is there more than one longest or shortest sequence? What are their identifiers? 
#+end_quote
*** Our Approach 
The way to go about this is:
- Find the length of each seqeunce in the dictionary and put this in another dictionary with keys as the identifiers and values as the length. Use this dictionary for comparison.
- Now, find the longest and shortest sequence and print their identifiers and lengths.
*** Creating a dictionary storing identifiers and sequence lengths and printing it 
#+begin_src python :tangle ./seqlen_compare.py 
  def seq_len_compare(seq_dict):
      """This function compares the length of DNA sequences in a dictionary
      """

      """first, we create a new sequence dictionary which stores lengths against identifiers
      """
      seq_len_dict = {}
      for keys,values in seq_dict.items():
          seq_len_dict[keys] = len(values)

      #for testing     
      # for keys,values in seq_len_dict.items():
      #     print(keys,values)


      """
      Now we compare the lengths of sequences in the dictionary.
      """

      #1. Maximum Length

      #first we initialize the maximum sequence length to 0
      max = 0
      #next we initialize a variable to store the identifier corresponding to the maximum sequence length
      max_identifier = ''
      #now we create a list which holds all identifiers which have the maximum value
      max_list = []
      for keys,values in seq_len_dict.items():
          if values>max:
              max = values
              max_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the maximum length
      for keys,values in seq_len_dict.items():
          if values==max:
              max_list.append(keys)

      #2. Minimum Length 
      #first we initialize the minimum sequence length to the maximum value obtained in the previous section
      min = max 
      #next we initialize a variable to store the identifier corresponding to the minimum sequence length
      min_identifier = ''
      #now we create a list which holds all identifiers which have the minimum value
      min_list = []
      for keys,values in seq_len_dict.items():
          if values<min:
              min = values
              min_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the minimum length
      for keys,values in seq_len_dict.items():
          if values==min:
              min_list.append(keys)

      """
      Now we print out the values obtained along with their identifiers.
      """
      #1. Print Maximum Length(s)
      print("\nThe following", len(max_list),  "sequence(s) has/have the maximum length of", max, '.')
      for x in range(len(max_list)):
          #print the identifiers in the max_list
          print("\n", max_list[x])

      #2. Print Minimum Length(s)
      print("\nThe following", len(min_list), "sequence(s) has/have the minimum length of", min,'.')
      for x in range(len(min_list)):
          #print the identifiers in the min_list
          print("\n", min_list[x])

      #to exit from the function
      return 0
#+end_src

#+RESULTS:
: None

* Identification and Mapping of Open Reading Frames (ORFs)
** Question 
#+begin_quote
(3) In molecular biology, a reading frame is a way of dividing the DNA sequence of nucleotides into a set of consecutive, non-overlapping triplets (or codons). Depending on where we start, there are six possible reading frames: three in the forward (5' to 3') direction and three in the reverse (3' to 5'). For instance, the three possible forward reading frames for the sequence AGGTGACACCGCAAGCCTTATATTAGC are: 

AGG TGA CAC CGC AAG CCT TAT ATT AGC

A GGT GAC ACC GCA AGC CTT ATA TTA GC

AG GTG ACA CCG CAA GCC TTA TAT TAG C 

These are called reading frames 1, 2, and 3 respectively. An open reading frame (ORF) is the part of a reading frame that has the potential to encode a protein. It starts with a start codon (ATG), and ends with a stop codon (TAA, TAG or TGA). For instance, ATGAAATAG is an ORF of length 9.

Given an input reading frame on the forward strand (1, 2, or 3) your program should be able to:
1. identify all ORFs present in each sequence of the FASTA file, and answer
2. what is the length of the longest ORF in the file?
3. What is the identifier of the sequence containing the longest ORF?
4. For a given sequence identifier, what is the longest ORF contained in the sequence represented by that identifier?
5. What is the starting position of the longest ORF in the sequence that contains it? The position should indicate the character number in the sequence. For instance, the following ORF in reading frame 1:

>sequence1

ATGCCCTAG

starts at position 1.

Note that because the following sequence:

>sequence2

ATGAAAAAA

does not have any stop codon in reading frame 1, we do not consider it to be an ORF in reading frame 1. 
#+end_quote

** Approach 
*** How we define the (open) reading frames for a sequence?
Open Reading Frames are substrings of DNA sequence strings which start with a start codon ATG and end with a stop codon, TAA, TAG or TGA.

Now, a given sequence will have 6 reading frames. Given a sequence, its easy to understand the first 3: we start accepting codons in multiples of 3 from the first position, the second and the third. 

What about the frames 4, 5 and 6? For them, we take the reverse strand, that is, the reverse complement of our sequence and take ORFs in it, as we had done for the forward strand.

The problem with the reverse strand is, we also have to map the starting and ending positions of the ORF, if any.

For this, when we get the starting position of the ORF in a reverse complement string, we use the subtract that position from the total length of the forward sequence. That gives us the starting position of the orf in the reverse direction, in the forward string itself.
*** Data storage scheme
Given the amount of information we have to process, its necessary to define a data structure for the same. 
#+begin_quote
Master Dictionary -> Sequence Dictionary -> Frame Dictionary -> ORF Dictionary[codon_list, starting position, ending position]
#+end_quote
- A dictionary containing all sequence identifers as keys, each of which contain another dictionary. 
  - Each frame containing information about 6 reading frames. For each reading frame:
    - A dictionary, whose keys correspond to an ORF discovered in the reading frame, if ORFs are found at all. Each ORF key will contain a list containing 3 things:
      - A nested list containing the codons of the ORF, from the start through the stop condons
      - Start position of the ORF,
      - Stop position of the ORF,  
#+begin_src python
  orf_dictionary = {
      identifier_1:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}},
      identifier_2:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}}
      .
      .
      .
      identifier_n:
      frame_dictionary_1{
          frame_1:
          frame_1_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          frame_2:
          frame_2_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]},
          .
          .
          .
          frame_6:
          frame_6_dictionary{
              ORF1:
              ORF1_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              ORF2:
              ORF2_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame],
              .
              .
              .
              ORFn:
              ORFn_list[orf_codon_list["startcodon", ..., "stopcodon"],
                        start_index_in_frame,
                        stop_index_in_frame]}}}
#+end_src

#+RESULTS:

*** Breaking down into parts
Having defined the data structure, let us break up the scheme of work into granular functions. 
1) [X] Function which takes the sequence, starts from the beginning and detects all ORFs and returns a dictionary of the type:
   #+begin_src python
     orf_dictionary = {
         ORF1:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position],
         ORF2:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position],
         .
         .
         .
         ORFn:[["start_codon, ...., stop_codon"]
               starting_position,
               stopping_position]}
   #+end_src

   #+RESULTS:
   
2) [X] Function which extracts all frames from a given sequence and returns a dictionary of type:
   #+begin_src python
     frame_dictionary = {
         frame_1:sequence1,
         frame_2:seqeunce2,
         .
         .
         .,
         frame_6:sequence6}
   #+end_src
:
   #+RESULTS:
   
3) [X] Function which takes *a sequence* and *returns a dictionary* of all the ORFs with their starting and stopping position in /all the frames/ and prints them.

4) [X] Function which *prints* all ORF information of *a sequence*.

5) [X] Function which compares the lengths of ORFs and returns the *longest and shortest ORF(s)* of *a sequence*.

   Having done the above, it is easy to scale it up for all FASTA sequences in a file.
   
6) [X] Function which prints ORF information of all sequences in the file.
   
7) [X] Function which compares the ORFs of a file and prints out the longest
   and shortest ORFs.

** Finding all ORFs in a single frame
*** The =frame_orfs()= function 
**** Newer
This was needed because the previous function considers all ORFs, even for the start codons that occur between a start and stop codon.

This new function ignores all start codons between a previously discovered start codon and a stop codon. 
#+begin_src python :session gdspyt :tangle ./orfs.py
  def frame_orfs(frame, fn=1):
      """
      This function extracts all non-overlapping ORFs from a sequence, 
      that is, ignoring start codons that fall between 
      a previous start codon and stop codon. 
      By default it returns start and end positions considering 
      the first frame of reference. However, if 2 or 3 is input, 
      it will calculate the frames accordingly. 

      """

      #define the start and stop codons
      start_codon = "ATG"
      stop_codon_tuple = ("TAA", "TAG", "TGA")

      #initialize the dictionary to store the orfs, in the form of
      # orf_dictionary = {
      #     ORF1:[["start_codon, ...., stop_codon"]
      #           starting_position,
      #           stopping_position],
      #     ORF2:[["start_codon, ...., stop_codon"]
      #           starting_position,
      #           stopping_position],
      #     .
      #     .
      #     .
      #     ORFn:[["start_codon, ...., stop_codon"]
      #           starting_position,
      #           stopping_position]}
      orf_dict = {}

      #trimming the frame (from the end) to number of nucleotides in multiples of 3
      trimmed_frame = ""
      for i in range((len(frame) - (len(frame)%3))):
          trimmed_frame = trimmed_frame + frame[i]

      #this will keep track of the orf number
      orf_count = 0  
      h = 0
      while (h <= (len(trimmed_frame) - 3)):
          codon = trimmed_frame[h:h+3]

          if codon == start_codon:
              start_position = h 

              #we move to check from the next codon, for a stop codon 
              h = h + 3
              #we now enter the stop codon searching loop 
              while (h <= (len(trimmed_frame) - 3)):
                  codon = trimmed_frame[h:h+3]

                  if codon in stop_codon_tuple:
                      stop_position = h 
                      orf_count = orf_count + 1 

                      #to assign a name to the ORF, which will act as a key in the orf_dict. 
                      orf_name = "ORF" + str(orf_count) 
                      orf_dict[orf_name] = []

                      #now we store the ORF information between start and stop positions in orf_dict
                      #first we store the list of codons in a nested list in the first position of the list corresponding to the orf_number 
                      orf_dict[orf_name].append([])
                      j = start_position
                      while(j <= stop_position):
                          codon = trimmed_frame[j:j+3]
                          orf_dict[orf_name][0].append(codon)
                          j = j + 3
                      #next we store the start and stop positions in the second and third positions of the orf_name list, respectively. fn is added the start/stop  position so that from the perspective of the sequence it considers the start position from index 1. If fn=2 or 3, then we assume the 2nd or 3rd frame of any sequence has been input and we adjust the start and stop positions accordingly
                      orf_dict[orf_name].append(start_position + fn)
                      #we add 3 to the stop position to consider the 3rd nucleotide of the stop codon as the stop position
                      orf_dict[orf_name].append((stop_position + fn + 3)) 

                      #we now break out of the stop codon searching loop 
                      break

                  #if the codon is not a stop codon, we increment h by 3 to search for another codon 
                  h = h + 3

          #if the codon is not a start codon, to move to the next test codon, have increment h by 3
          h = h + 3 

      return orf_dict 
#+end_src
**** Deprecated 
#+begin_src python :session gdspyt :tangle no  
  def frame_orfs(frame):
      #define the start and stop codons
      start_codon = "ATG"
      # print("Calculating all ORFs in frame of length", len(frame), "...")
      stop_codon_tuple = ("TAA", "TAG", "TGA")

      #trimming the frame (from the end) to number of nucleotides in multiples of 3
      trimmed_frame = ""
      for i in range((len(frame) - (len(frame)%3))):
          trimmed_frame = trimmed_frame + frame[i]

      #now get all the positions of start and stop codons
      start_pos_list = []
      stop_pos_list = []

      #initialize the while loop variable
      h = 0
      while (h <= (len(trimmed_frame) - 3)):
          codon = trimmed_frame[h:h+3]

          #storing the start positions 
          if codon == start_codon:
              start_pos_list.append(h)

          #storing the stop positions 
          if codon in stop_codon_tuple:
              # print(codon)
              stop_pos_list.append(h)

          #incrementing i by 3
          h = h + 3

      # print(start_pos_list)
      # print(stop_pos_list)

      #Now getting the ORFs.     
      orf_dict = {}
      i = 1 #initializing a variable to store the ORF number
      for start_position in start_pos_list:
          # a new list of stop positions is to be built which will contain stop positions after the start position
          new_stop_pos_list = []
          for stop_position in stop_pos_list:
              if stop_position > start_position:
                  new_stop_pos_list.append(stop_position)

          #print(new_stop_pos_list)
          for stop_posi in new_stop_pos_list:
              # print(trimmed_frame[stop_posi:stop_posi+3])
              orf_key = "ORF"+str(i)
              orf_dict[orf_key] = [[],
                                   start_position + 1, #+1 to start indexing from 1
                                   stop_posi + 3]
              for j in range(start_position, stop_posi+1):
                  orf_dict[orf_key][0].append(trimmed_frame[j:j+3])
              #updating ORF number 
              i = i + 1

      return orf_dict

#+end_src

#+RESULTS:

*** Testing the =frame_orfs()= function
#+begin_src python :session gdspyt :tangle no
  orfdict = frame_orfs(test_sequence)
  print("Found", len(orfdict), "open reading frames in frame.")
  for ORF, info in orfdict.items():
      print(ORF, "\n", info[0], "\n", info[1], info[2])
      # print(ORF, "\n", info[0][0], info[0][1], info[0][2], "...", info[0][-2], info[0][-1], "\n", info[1], info[2])
#+end_src

Thus, we have successfully found all of the ORFs in one single frame.

** Finding all the frames of a sequence
The first 3 frames of the sequence can be found by starting from the first, second and third position, respectively, of the sequence in the forward direction.
For the next 3 frames, the reverse complement of the sequence has to be used. 
*** Finding reverse complement of sequences
**** Revese of a Sequence
***** The =sequence_reverse()= function 
#+begin_src python :session gdspyt :tangle ./orfs.py 
  #This is a simple function to reverse a string
  def sequence_reverse(sequence):
      """
      This program finds the reverse of the sequence entered. 
      """
      #first we initialize the string variable which will contain our reversed string
      reversed_sequence = ''
      #next we initialize our loop variable to the value of the last index of 'sequence'
      i=len(sequence)-1
      #we use a while loop, which continues till i is greater than or equal to zero 
      while i>=0:
          #we concatenate each letter from the end of the sequence entered to form a new string which has the order reversed
          reversed_sequence = reversed_sequence+sequence[i]
          #in each iteration we decrease the value of the variable i to maintain the loop condition
          i=i-1

      #finally, exit from the function and return the reversed sequence    
      return reversed_sequence
#+end_src

#+RESULTS:
***** Testing the =sequence_reverse()= function 
#+begin_src python :session gdspyt :results output  
print(sequence_reverse(test_sequence))
#+end_src

#+RESULTS:
: CTGCTGGCTGGCGCGCCGCCAGCGCTTCCGCGAGCCGCAGCGGGGCCTCTTTCAGGTCTAGAAGTGCGACTGGAGCCCGCCGCTGATACCGGCCGCGAGCTGCGGCTGCAGCCTGATGCACCAGCTTCGGCGGGTGCACAGGCGGCGCATGGAGCGCCGGCCGGTAGAGCCGGGGCAGTTCTGCTAGACCTGCGCGCTCCTGCTAGACGCGCCGCCGATAATGGCGGGCTACCACGACGTAGCGCAGCTGTAGCCGCACCTGCCGTCGCCGCGGCACGCGCTGACCGTCGTGCACCAGCAGCCGGTCAGACACGACTTCCCGAGCGGCGAGCTCGCGTGCTGCTACGAGTTCGCGCCGTGGCTAGGCTCGGACTGGCTTCCGCACTGCTTGTCGGGCATGCCGAAGGGCTACGTCCATAGCCAAGTAGTCTGGCTCCGGCTGCACGGCCAGGTCTGCACCGCGAGCCCGCCGTTGAGCGTATGCCGCAAGCACTACCTTTGCGACCAGCTGCTCGAGCGCGTGAGCCGCGCCGTCCTAGGCCAGCGGATGGCCTACTGCGCCGACCGGCCGGGGCTCGTGCGGCGCGTAGCCGTCCGCGAGCGCGACCGGCAGCTGTTCAGGCCGATGCCGCGCGCGTGCGACGGCCGGCCCGTGCGCACCCCGCAGCGCTACGTGCTTTGCCGGCCGAGCCAGCAGCGCATGCACTGCCTTCACAGCTAGCTTCGCGTTGTTGGCGCGCACGTAGCGCACTGCCGGCCGCACATACGCCCGGCGTAGCAGTTGGGCTGGCCGCGCGTTCGCGTCTAGGTCCCGCCGCGCGACAAGCCAGAGCGCTGCTGCTTCGGGCCGAAGCGCTAGCTGCAGCTGGTACCGCGCCAGGCGTTGCGGCCAAAGCGGCTGATAAGCGGCTATGCGTACGTCCTTCGCGGCGGCCACCTACAGAAGAAGCACGGCAGCCTGCGGGTCGGCTGGCCCAACTCGCTGCGGCCGCACGGCGGCTAGCGCGGCCGCCACCGGTTGCCACGCAAGCACGACTGGCCGCTCGCCCACGTACGCAACGGCAAGGGGGGCTACGACCAGCGCAGCTGGCGGGGGCACTACGGCCGCCGGGGGCGCTGCCGCCGGCTGCTCCTAGGCATGCCGTTGGACGGCCGGCCGCCGACGGCCGACGGCGTGTTCCAGTTCGGA

**** Complement of a sequence
***** The =dna_complement()= function 
#+begin_src python :session gdspyt :tangle ./orfs.py 
  #this function returns the complement of a DNA sequence entered, NOT the reverse complement
  def dna_complement(sequence):
      """
      This function returns the complementary sequence of a DNA sequence entered.

      """
      #first we define a dictionary containing all the bases and their complements, even in lowecase
      bases_dict = {"A":"T", "a":"t", "C":"G", "c":"g", "G":"C", "g":"c", "T":"A", "t":"a", "N":"N", "n":"n"}

      #we initialize a string variable to store the complementary sequence
      complement = ''

      #next we loop over our sequence and make a new complementary string
      for i in sequence:
          complement = complement + bases_dict[i]

      #finally, return the complement sequence and exit from the function
      return complement
#+end_src

#+RESULTS:

***** Testing the =dna_complement()= function
#+begin_src python :session gdspyt :results output  
print(dna_complement(test_sequence))
#+end_src

#+RESULTS:
: TCCGAACTGGAACACGCCGTCGGCCGTCGGCGGCCGGCCGTCCAACGGCATGCCTAGGAGCAGCCGGCGGCAGCGCCCCCGGCGGCCGTAGTGCCCCCGCCAGCTGCGCTGGTCGTAGCCCCCCTTGCCGTTGCGTACGTGGGCGAGCGGCCAGTCGTGCTTGCGTGGCAACCGGTGGCGGCCGCGCTAGCCGCCGTGCGGCCGCAGCGAGTTGGGCCAGCCGACCCGCAGGCTGCCGTGCTTCTTCTGTAGGTGGCCGCCGCGAAGGACGTACGCATAGCCGCTTATCAGCCGCTTTGGCCGCAACGCCTGGCGCGGTACCAGCTGCAGCTAGCGCTTCGGCCCGAAGCAGCAGCGCTCTGGCTTGTCGCGCGGCGGGACCTAGACGCGAACGCGCGGCCAGCCCAACTGCTACGCCGGGCGTATGTGCGGCCGGCAGTGCGCTACGTGCGCGCCAACAACGCGAAGCTAGCTGTGAAGGCAGTGCATGCGCTGCTGGCTCGGCCGGCAAAGCACGTAGCGCTGCGGGGTGCGCACGGGCCGGCCGTCGCACGCGCGCGGCATCGGCCTGAACAGCTGCCGGTCGCGCTCGCGGACGGCTACGCGCCGCACGAGCCCCGGCCGGTCGGCGCAGTAGGCCATCCGCTGGCCTAGGACGGCGCGGCTCACGCGCTCGAGCAGCTGGTCGCAAAGGTAGTGCTTGCGGCATACGCTCAACGGCGGGCTCGCGGTGCAGACCTGGCCGTGCAGCCGGAGCCAGACTACTTGGCTATGGACGTAGCCCTTCGGCATGCCCGACAAGCAGTGCGGAAGCCAGTCCGAGCCTAGCCACGGCGCGAACTCGTAGCAGCACGCGAGCTCGCCGCTCGGGAAGTCGTGTCTGACCGGCTGCTGGTGCACGACGGTCAGCGCGTGCCGCGGCGACGGCAGGTGCGGCTACAGCTGCGCTACGTCGTGGTAGCCCGCCATTATCGGCGGCGCGTCTAGCAGGAGCGCGCAGGTCTAGCAGAACTGCCCCGGCTCTACCGGCCGGCGCTCCATGCGCCGCCTGTGCACCCGCCGAAGCTGGTGCATCAGGCTGCAGCCGCAGCTCGCGGCCGGTATCAGCGGCGGGCTCCAGTCGCACTTCTAGACCTGAAAGAGGCCCCGCTGCGGCTCGCGGAAGCGCTGGCGGCGCGCCAGCCAGCAG

**** Reverse complement of a sequence
***** The =reverse_complement()= function 
#+begin_src python :session gdspyt :tangle ./orfs.py
  #a simple function which calls the reverse string and sequence complement functions to calculate the reverse complements
  def reverse_complement(sequence):
      return(dna_complement(sequence_reverse(sequence)))
    
#+end_src

#+RESULTS:
***** Testing the =reverse_complement()= function
#+begin_src python :session gdspyt :results output
print(reverse_complement(test_sequence))
#+end_src

#+RESULTS:
: GACGACCGACCGCGCGGCGGTCGCGAAGGCGCTCGGCGTCGCCCCGGAGAAAGTCCAGATCTTCACGCTGACCTCGGGCGGCGACTATGGCCGGCGCTCGACGCCGACGTCGGACTACGTGGTCGAAGCCGCCCACGTGTCCGCCGCGTACCTCGCGGCCGGCCATCTCGGCCCCGTCAAGACGATCTGGACGCGCGAGGACGATCTGCGCGGCGGCTATTACCGCCCGATGGTGCTGCATCGCGTCGACATCGGCGTGGACGGCAGCGGCGCCGTGCGCGACTGGCAGCACGTGGTCGTCGGCCAGTCTGTGCTGAAGGGCTCGCCGCTCGAGCGCACGACGATGCTCAAGCGCGGCACCGATCCGAGCCTGACCGAAGGCGTGACGAACAGCCCGTACGGCTTCCCGATGCAGGTATCGGTTCATCAGACCGAGGCCGACGTGCCGGTCCAGACGTGGCGCTCGGGCGGCAACTCGCATACGGCGTTCGTGATGGAAACGCTGGTCGACGAGCTCGCGCACTCGGCGCGGCAGGATCCGGTCGCCTACCGGATGACGCGGCTGGCCGGCCCCGAGCACGCCGCGCATCGGCAGGCGCTCGCGCTGGCCGTCGACAAGTCCGGCTACGGCGCGCGCACGCTGCCGGCCGGGCACGCGTGGGGCGTCGCGATGCACGAAACGGCCGGCTCGGTCGTCGCGTACGTGACGGAAGTGTCGATCGAAGCGCAACAACCGCGCGTGCATCGCGTGACGGCCGGCGTGTATGCGGGCCGCATCGTCAACCCGACCGGCGCGCAAGCGCAGATCCAGGGCGGCGCGCTGTTCGGTCTCGCGACGACGAAGCCCGGCTTCGCGATCGACGTCGACCATGGCGCGGTCCGCAACGCCGGTTTCGCCGACTATTCGCCGATACGCATGCAGGAAGCGCCGCCGGTGGATGTCTTCTTCGTGCCGTCGGACGCCCAGCCGACCGGGTTGAGCGACGCCGGCGTGCCGCCGATCGCGCCGGCGGTGGCCAACGGTGCGTTCGTGCTGACCGGCGAGCGGGTGCATGCGTTGCCGTTCCCCCCGATGCTGGTCGCGTCGACCGCCCCCGTGATGCCGGCGGCCCCCGCGACGGCGGCCGACGAGGATCCGTACGGCAACCTGCCGGCCGGCGGCTGCCGGCTGCCGCACAAGGTCAAGCCT

*** The =frame_extract()= function
For the coursera course I will include only the forward reading frames, not the reverse reading frames. This will enable me to pass the test.

**** Using only the forward 1, 2 and 3 reading frames
#+begin_src python :session gdspyt :tangle ./orfs.py 
  def frame_extract(sequence):
      """This function extracts all the 6 ORFs from a given sequence."""

      #initializing the dictionary which will store all the sequences of all the frames 
      frame_dictionary = {}

      #this variable stores the frame numbers 
      frame_no = 1

      #loop extracting frames 1, 2 and 3
      for i in range(3):
          frame_name = "Frame" + str(frame_no)
          frame_dictionary[frame_name] = sequence[i:]
          frame_no = frame_no + 1

      return(frame_dictionary)
#+end_src
**** Using all 6 reading frames
#+begin_src python :session gdspyt :tangle no  
  def frame_extract(sequence):
      """This function extracts all the 6 ORFs from a given sequence."""

      #initializing the dictionary which will store all the sequences of all the frames 
      frame_dictionary = {}

      #this variable stores the frame numbers 
      frame_no = 1

      #loop extracting frames 1, 2 and 3
      for i in range(3):
          frame_name = "Frame" + str(frame_no)
          frame_dictionary[frame_name] = sequence[i:]
          frame_no = frame_no + 1

      # print(frame_no)

      sequence_reverse_complement = reverse_complement(sequence)

      #loop extracting frames 4, 5, and 6
      for i in range(3):
          frame_name = "Frame" + str(frame_no)
          frame_dictionary[frame_name] = sequence_reverse_complement[i:]
          frame_no = frame_no + 1

      # print(frame_no)

      return(frame_dictionary)
#+end_src

#+RESULTS:

*** Testing the =frame_extract()= function
#+begin_src python :session gdspyt :tangle no
  frm_dic = frame_extract(test_sequence)
  for keys, items in frm_dic.items():
      print(keys, "\n", items, "\n")
#+end_src

#+RESULTS:
: None

** Finding all ORFs in a sequence
To find all the ORFs in a sequence, we simply pass a sequence to a function which will call  =frame_extract()= to get a dictionary of frames. Another loop will pass the entries of this frame dictionary to =frame_orfs()= function, to get all the ORFs in the frame. These will be stored in another dictionary and returned.

*** The =sequence_orfs()= function 
#+begin_src python :session gdspyt :tangle ./orfs.py 
  def sequence_orfs(sequence, fn=0):
      """This function takes a sequence and finds and returns all the ORFs in a frame of choice. By default though, it will return ORFs in all frames."""
      #initializing the dictionary to store all the frame information of the sequence 
      sequence_orfs_dictionary = {}

      #calling the frame_extract() to find all the frames and store it in frames_dictionary variable 
      frames_dictionary = frame_extract(sequence)

      #this loop goes through all the frames in the dictionary, calls the frame_orfs() function for each frame and stores the output in frames_dictionary.
      if(fn == 0):
          fn = 1
          for frame, frame_sequence in frames_dictionary.items():
              #if Frame4 is reached, we restart from fn=1. This will again increment to 2 and 3 when frames 5 and 6 are reached, respectively. 
              if(fn == 4):
                  fn = 1 
              sequence_orfs_dictionary[frame] = frame_orfs(frame_sequence, fn)
              fn = fn + 1 
      #the else case is when a frame number has been entered. Start and stop positions are adjusted accordingly in frame_orfs()
      else:
          frame = "Frame"+str(fn)
          sequence_orfs_dictionary[frame] = frame_orfs(frames_dictionary[frame], fn)


      #for frame 5, 6, and 7, which are the reverse complement frames, we need to alter the start and stop positions of the frame, so that they are with respect to the forward sequence

      reverse_frames_tuple = ("Frame4", "Frame5", "Frame6")

      #calculating the length of the sequence
      seqlen = len(sequence)

      # now altering the start and stop positions 
      for frame, ORF_dict in sequence_orfs_dictionary.items():
          if frame in reverse_frames_tuple:
              for orfs, info in ORF_dict.items():
                  info[1] = seqlen - info[1]
                  info[2] = seqlen - info[2]

      return sequence_orfs_dictionary
#+end_src

*** Testing the =sequence_orfs()= function
#+begin_src python :session gdspyt :tangle no
  fn = 0
  if(fn == 0):
      print("The ORFs in all the frames are:")
  else:
      print("Frame", fn, "contains the following ORFs:")
  print(sequence_orfs(test_sequence, fn))
#+end_src
** Printing all ORFs in a sequence 
Now we take the have to print the output from the =sequence_orfs()= function
***  Function =print_sequence_orfs()= 
#+begin_src python :session gdspyt :tangle ./orfs.py
  def print_sequence_orfs(sequence, fn=0):
      """This function prints the ORF information of a sequence in a particular frame in a presentable format. By default it prints all the frames of the sequence."""

      seq_orf_info = sequence_orfs(sequence, fn)

      for frame, frame_dict in seq_orf_info.items():
          print("*** _ _ _ _ _ _", frame, "_ _ _ _ _ _")
          print("Retrieving", len(frame_dict), "sequences in", frame, "...")
          for orf, orf_dict in frame_dict.items():
              print("***", orf, "\n", orf_dict[0][0], orf_dict[0][1], "...", orf_dict[0][-2], orf_dict[0][-1])
              print(" ", orf_dict[1], "           ", orf_dict[2])

      return 0
#+end_src
*** Testing  =print_sequence_orfs()= 
#+begin_src python :session gdspyt :tangle no
  print_sequence_orfs(test_sequence)
#+end_src
** Print all ORFs in the file
*** Function to get the and print the ORFs  
#+begin_src python :session gdspyt :tangle ./orfs.py
  def print_orfs_of_file(fasta_dict):
      """This function takes as input a dictionary containing all sequences in a file in the format "identifier:sequence" and prints all the ORFs of all reading frames of all sequences of a file."""

      for identifier, sequence_orf_info in fasta_dict.items():
          print("** ++++++", identifier, "++++++")
          print_sequence_orfs(sequence_orf_info)
#+end_src
** Comparing and printing the longest and shortest ORFs of a sequence 
Now we compare all the ORFs in a given sequence and print them. The function will obtain the sequence dictionary from the =sequence_orfs()= function and return the following information.

#+begin_src python
  longest_orf_length
  longest_orf_dictionary = {frame_no: {orfn1:[start_pos, end_pos], orfn2:[start_pos, end_pos],...}}
  shortest_orf_length 
  shortest_orf_dictionary = {frame_no: {orfn1:[start_pos, end_pos], orfn2:[start_pos, end_pos],...}}
#+end_src
*** The =compare_seq_orfs()= function 
#+begin_src python :session gdspyt :tangle ./orfs.py 
  def compare_seq_orfs(sequence, fn=0):
      """This function compares all the ORFs in a sequence."""

      #getting the ORF information of the sequences 
      seq_orf_info = sequence_orfs(sequence, fn)

      #a dictionary to store the lengths of all the ORFs defined in seq_orf_info
      seq_orf_len_dict = {}

      #this loop builds the seq_orf_len_dict as well as finds the maximum length
      max_len = 0
      for frame, frame_dict in seq_orf_info.items():
          seq_orf_len_dict[frame] = {}
          for orf, orf_list in frame_dict.items():
              #we subtract the starting and ending positions of the ORFs
              orf_len = abs(orf_list[1] - orf_list[2])
              #initialize a new entry inside of seq_orf_len_dict, corresponding to a key, frame, which stores the starting and ending position of the ORF and the orf length. 
              seq_orf_len_dict[frame][orf] = [orf_list[1], orf_list[2], orf_len]
              if orf_len >= max_len:
                  max_len = orf_len

      #now we find the minimum length 
      min_len = max_len 
      for frame, frame_dict in seq_orf_len_dict.items():
          for orf, orf_len_info in frame_dict.items():
              #remember length is stored in the 3rd position of the orf_len_info list 
              orf_len = orf_len_info[2]
              if orf_len <= min_len:
                  min_len = orf_len


      #since there can be more than one sequences with the maximum or minimum lengths, we initialize a dictionary which will store all frames and ORFs corresponting to the maximum and minimum lengths, along with the starting and ending positions of the ORF
      max_len_dict = {}
      min_len_dict = {}
      for frame, frame_dict in seq_orf_len_dict.items():
          for orf, orf_len_info in frame_dict.items():
              if orf_len_info[2] == max_len:
                  max_len_dict[frame] = {}
                  max_len_dict[frame][orf] = [seq_orf_info[frame][orf][1], seq_orf_info[frame][orf][2]]
              if orf_len_info[2] == min_len:
                  min_len_dict[frame] = {}
                  min_len_dict[frame][orf] = [seq_orf_info[frame][orf][1], seq_orf_info[frame][orf][2]]

      return (max_len, max_len_dict, min_len, min_len_dict, seq_orf_len_dict)
#+end_src
*** Testing =compare_seq_orfs()= function
#+begin_src python :session gdspyt :tangle ./orfs.py
  def print_seq_orf_info(sequence, fn=0):
      """
      This function prints in a presentable manner, 
      the sequence information of any sequence enterd,
      by calling the compare_seq_orfs().

      """
      comparison_tuple = compare_seq_orfs(sequence)
      print("Max length:", comparison_tuple[0])
      print("\n\nORFs with max length:")
      print("\nFrame \t ORF \t Start \t Stop")
      for frame, frame_info in comparison_tuple[1].items():
          for orf, orf_info in frame_info.items():
              print(frame, "\t", orf, "\t", orf_info[0], "\t", orf_info[1])
      print("\nMin length:", comparison_tuple[2])
      print("\n\nORFs with min length:")
      print("\nFrame \t ORF \t Start \t Stop")
      for frame, frame_info in comparison_tuple[1].items():
          for orf, orf_info in frame_info.items():
              print(frame, "\t", orf, "\t", orf_info[0], "\t", orf_info[1])

      return 0
#+end_src
** Printing the longest and shortest ORFs among all sequences in a file
*** Procedure 
Till now we can compare all the ORFs in a particular sequence with the =compare_seq_orfs()= function, which returns a tuple of type =(max_len, max_len_dict, min_len, min_len_dict)=.

1. Now, to compare ORFs of all sequences in a file, the =file_ORF_compare_lengths()= function must first store the maximum and minimum ORF lengths of all the sequences in a dictionary of type: 

#+begin_src python
  file_orf_len_dict = {
      sequence_id_1: (
          max_len, max_len_dict = {frame_a1:
                                   {ORF_a1: [start_pos, end_pos],
                                    .
                                    .
                                    .,
                                    ORF_an: [start_pos, end_pos]},
                                   .
                                   .
                                   .
                                   frame_an: [ORF_a1, ..., ORF_an]},
          min_len, min_len_dict = {frame_a1:
                                   {ORF_a1: [start_pos, end_pos],
                                    .
                                    .
                                    .,
                                    ORF_an: [start_pos, end_pos]}}),
      .
      .
      .,
      sequence_id_n: (
          max_len, max_len_dict = {frame_a1:
                                   {ORF_a1: [start_pos, end_pos],
                                    .
                                    .
                                    .,
                                    ORF_an: [start_pos, end_pos]},
                                   .
                                   .
                                   .
                                   frame_an: [ORF_a1, ..., ORF_an]},
          min_len, min_len_dict = {frame_a1:
                                   {ORF_a1: [start_pos, end_pos],
                                    .
                                    .
                                    .,
                                    ORF_an: [start_pos, end_pos]}})}
#+end_src

2. Then there will be a comparison between the sequences, which has the longest and shortest ORFs. The =file_ORF_compare_lengths()= function will return the lengths of the longest and shortest ORFs in the file.

3. The next function =get_all_ORFs_of_length(x)= will fetch all the ORFs in a file corresponding to a given length =x= and return a dictionary of type:

#+begin_src python
  file_ORFs_len_x_dict =  {sequence_a1:
                           {frame_b1:
                            {orf_c1: [start, end], ..., orf_cn: [start, end]},
                            .
                            .
                            .,
                            frame_bn:
                            {orf_c1: [start, end], ..., orf_cn: [start, end]}},
                           .
                           .
                           .,
                           sequence_an:
                           {frame_b1:
                            {orf_c1: [start, end], ..., orf_cn: [start, end]},
                            .
                            .
                            .,
                            frame_bn:
                            {orf_c1: [start, end], ..., orf_cn: [start, end]}}}
#+end_src

4. A final function, =print_longest_shortest_ORFs(fasta_dict)= will process the longest and shortest ORFs returned by the =file_ORF_compare_lengths()= into the =get_all_ORFs_of_length()= function to print all longest and shortest ORFs in a file. 


*** Getting the max and min lengths of an ORF
**** The =file_ORF_compare_lengths()= function
#+begin_src python :session gdspyt :tangle ./orfs.py
  def file_ORF_compare_lengths(fasta_dict, fn=0):
   """This function compares the maximum and minimum lengths of all ORFs in all sequences in a file and returns the lengths of the longest and shortest ORF in the file."""
   #initializing the dictionary which will store the ORF lengths information from calling compare_seq_orfs() for all the sequences 
   file_ORF_len_dict = {}

   #building the file_ORF_len_dict for all sequences in fasta_dict 

   for identifier, sequence in fasta_dict.items():
    file_ORF_len_dict[identifier] = compare_seq_orfs(sequence, fn)
    # print(file_ORF_len_dict[identifier]) #for testing 

   #now we will go over the entries of the dictionary and get the values of the maximum ORF
   max_len_file = 0
   for identifier, sequence_info in file_ORF_len_dict.items():
    #the first entry in the tuple returned by compare_seq_ORFs contains the maximum length of the sequence 
    orf_len = sequence_info[0]
    if orf_len > max_len_file:
     max_len_file = orf_len

   #getting the value of the minimum length of the ORF
   min_len_file = max_len_file
   for identifier, sequence_info in file_ORF_len_dict.items():
    #the third entry in the tuple returned by compare_seq_ORFs contains the minimum length of the sequence 
    orf_len = sequence_info[2]
    # print("Orf_len:", orf_len) #to test 
    #because certain frames might contain no ORF at all, we have to exclude from consideration a minimum length of 0. 
    if ((orf_len <= min_len_file) & (orf_len!=0)):
     min_len_file = orf_len
     # print("Changed min len:", min_len_file) #to test

   # print(max_len_file, min_len_file)
   return (max_len_file, min_len_file) 
#+end_src

**** Testing =file_ORF_compare_lengths()= function
#+begin_src python :session gdspyt :tangle no
  print(file_ORF_compare_lengths(fast_dict))
#+end_src


*** Getting all ORFs in  a file of length x
**** The =get_all_ORFs_of_length()= function
This will allow is to get all ORFs in the file corresponding to a given length
#+begin_src python :session gdspyt :tangle ./orfs.py
  def get_all_ORFs_of_length(fasta_dict, x):
      """This function gets all ORFs of length x from a file whose sequence information has been stored in fasta_dict"""
      all_ORFs_dict = {}

      file_ORF_lengths_dict = {}
      for identifier, sequence in fasta_dict.items():
          seq_info = compare_seq_orfs(sequence)
          file_ORF_lengths_dict[identifier] = seq_info[4]


      #initializing the list containing ORF of length x
      dict_file_orfs_length_x = []
      for identifier, identifier_info in file_ORF_lengths_dict.items():
          for frame, frame_ORF_info in identifier_info.items():
              for ORF, orf_info in frame_ORF_info.items():
                  if orf_info[2] == x:
                      #remember, orf_info = [start, stop, length]
                      ORF_coordinates = (identifier, frame, ORF, orf_info[0], orf_info[1], orf_info[2])
                      dict_file_orfs_length_x.append(ORF_coordinates)

      return dict_file_orfs_length_x
#+end_src

**** Test =get_all_ORFs_of_length()= function
#+begin_src python :session gdspyt :tangle no
  #1686nts happens to be the longest ORF in the file 
  print(get_all_ORFs_of_length(fast_dict, 1686))
#+end_src

*** Printing all the longest and shortest ORFs in a file
**** the =print_longest_shortest_ORFs(fasta_dict)= function
#+begin_src python :session gdspyt :tangle ./orfs.py
  def print_longest_shortest_ORFs(fasta_dict, fn=0):
      """This function prints all the longest and shortest ORFs, considering all the frames of all sequences in a file, by default. However, if a frame number is entered, it can print out the longest ORFs in that particular frame."""

      #first we call the file_ORF_compare_lengths() to store the maximum and minimum ORF lengths of the file in a tuple returned by the function 
      max_min_tuple = file_ORF_compare_lengths(fasta_dict, fn)
      #then we store the all the ORFs having the maximum and minimum lengths. We get a list containing nested lists of the form:
      #[identifier, frame, ORF, start, stop, length]
      max_ORF_list = get_all_ORFs_of_length(fasta_dict, max_min_tuple[0])
      min_ORF_list = get_all_ORFs_of_length(fasta_dict, max_min_tuple[1])

      #Finally to print them out in a nicely formatted way
      frame_name = "Frame"+str(fn)
      if(fn == 0):
          print("\n\nThe ORF(s) with the maximum lengths of", max_min_tuple[0], "are:")
      else:
          print("\n\nThe ORF(s) with the maximum lengths of", max_min_tuple[0], "in", frame_name, "are:")
        
      print("__________ \t\t\t _____ \t___ \t _____ \t ____ \t ______")
      print("\nIdentifier \t\t\t Frame \tORF \t Start \t Stop \t Length")
      print("__________ \t\t\t _____ \t___ \t _____ \t ____ \t ______")
      for i in range(len(max_ORF_list)):
          print(max_ORF_list[i][0], max_ORF_list[i][1], max_ORF_list[i][2], "\t", max_ORF_list[i][3], "\t", max_ORF_list[i][4], "\t", max_ORF_list[i][5])
        
      if(fn == 0):
          print("\n\nThe ORF(s) with the minimum lengths of", max_min_tuple[1], "are:")
      else:
          print("\n\nThe ORF(s) with the minimum lengths of", max_min_tuple[1], "in", frame_name, "are:")

      print("__________ \t\t\t _____ \t___ \t _____ \t ____ \t ______")
      print("\nIdentifier \t\t\t Frame \tORF \t Start \t Stop \t Length")
      print("__________ \t\t\t _____ \t___ \t _____ \t ____ \t ______")
      for i in range(len(min_ORF_list)):
          print(min_ORF_list[i][0], min_ORF_list[i][1], min_ORF_list[i][2], "\t", min_ORF_list[i][3], "\t", min_ORF_list[i][4], "\t", min_ORF_list[i][5])

      return 0 
#+end_src
** Printing the longest and shortest ORF in the file corresponding to a particular frame number 'fno'
- for this we call the function to get the length information of all the sequences in the file
* Mapping Repeats in the File

** Question
(4) A repeat is a substring of a DNA sequence that occurs in multiple copies (more than one) somewhere in the sequence. Although repeats can occur on both the forward and reverse strands of the DNA sequence, we will only consider repeats on the forward strand here. Also we will allow repeats to overlap themselves. For example, the sequence ACACA contains two copies of the sequence ACA - once at position 1 (index 0 in Python), and once at position 3.

Given a length n, your program should be able to identify all repeats of length n in all sequences in the FASTA file.

Your program should also determine how many times each repeat occurs in the file, and which is the most frequent repeat of a given length.

** Our Approach 
The question asks us to find all repeats of length n in a DNA sequence.

Logically thinking, probability of a large sequence (say, >5nt) occuring purely by chance at random in a DNA sequence in very slim. Thus, if they are occuring two or more times, then they must be biologically relavant, and most probably they are repeats.
   
Thus, for the repeats problem, we take this approach:

1. [X] First look at how many times a *given repeat unit* occurs in a sequence and return a value with the functio =get_repeat_frequency(sequence, repeat_unit)= 

2. [X] Then use another function =get_seq_repeat_info(sequence, n)= to *extract all unique units of length n*, which occur > 1 times in a sequence, and return a dictionary:
      
   #+begin_src python
     sequence_repeats_dict = {unit_1:times, ..., unit_n:times}
   #+end_src

   It will extract all the possible substrings of length n from the sequence and call the =get_repeat_frequency()= for each substring. If the frequency > 1, then it will append it to the =sequence_repeats_dict=.
      
3. Now to scale this up to a file:
        
   1) [X] A function =get_file_repeat_units(fasta_dictionary, n)= accepts a FASTA parsed dictionary and and a unit length n and gets the =file_repeat_info= dictionary containing repeat information (of length n) corresponding to all sequence IDs in the file, by calling the =get_seq_repeat_info(sequence)= for all sequences.

     #+begin_src python
       file_repeat_info = {
           sequence_ID_1:{
               repeat_unit_1:times_repeated,
               .
               .
               ., 
               repeat_unit_n:times_repeated},
           .
           .
           .,
           sequence_ID_n:{
               repeat_unit_1:times_repeated,
               .
               .
               ., 
               repeat_unit_n:times_repeated}}
    
     #+end_src

      Now it needs to find the total the occurances of all unique sequences in the file. The strategy for this could be:
      Go over the =file_repeat_info= obtained to store in a dictionary all the unique repeats.

      Finally it returns the occurance of all unique repeat units in the file. 

   2) [X] Now another function =max_occurance_n(fasta_dict, n)= will compare all the unique repeat units of length n and return the unit(s) with the max occurance and the number of times it has occured, in a list of type:

      #+begin_src python
      max_repeats_list = [max_times, repeat_unit_1, ..., repeat_unit_n]
      #+end_src


4. Outputs
   1. [X] For a given repeat unit, we want to print the number of times it occurs in the file. For this, =get_repeat_frequency(repeat_unit)= will be called iteratively over all the sequences in the file to build a dictionary which contains the number of times the repeat unit occurs in each sequence.
      This can be totaled to find the repeat times. 
   2. [X] We want to print the maximum occurance all repeats of length n, along with all the repeats which occur at maximum frequency. 
      =print_max_repeat(fasta_dict, n)= will print the dictionary returned by =max_occurance_n()=



** Getting frequency of a given repeat in a sequence 

*** The =get_repeat_frequency(sequence, repeat_unit)= function

#+begin_src python :session gdspyt :tangle ./repeats.py
  def get_repeat_frequency(sequence, repeat_unit):
      """This function returns the number of times a repeat unit occurs in a sequence."""

      repeat_count = 0
      #we start from the first position of the sequence and take out test windows corresponding to length of repeat unit.
      repeat_len = len(repeat_unit)
      seq_len = len(sequence)
      i = 0
      #we want slide the window till the last position in the sequence which can accomodate the windo
      while (i <= (seq_len - repeat_len)):
          test_window = sequence[i:(i + repeat_len)]
          if test_window == repeat_unit:
              repeat_count = repeat_count + 1

          i = i + 1

      return repeat_count
#+end_src

      
*** Testing =get_repeat_frequency()=

#+begin_src python :session gdspyt :tangle no :results output
  print(get_repeat_frequency(test_sequence, "TTGTTGCGCTTCGA"))
#+end_src

#+RESULTS:

** Getting the frequency of all repeat units of length n in a sequence

*** The =get_seq_repeat_info(sequence, n)= function

#+begin_src python :session gdspyt :tangle ./repeats.py 
  def get_seq_repeat_info(sequence, n):
      """This function gets a dictionary containing all subsequences of length n which occur repeatedly, that is, two times or more, in a sequence."""

      sequence_repeats_dict = {}

      #we start from the first position and extract the substrings of length l. We stop at the last last position minus the length of the repeat. 
      i = 0
      seqlen = len(sequence)
      while (i <= (seqlen - n)):
          test_repeat_unit = sequence[i:(i + n)]
          #now we get the frequency of this unit in our sequence
          frequency = get_repeat_frequency(sequence, test_repeat_unit)
          if (frequency > 1):
              sequence_repeats_dict[test_repeat_unit] = frequency
              
          i = i + 1 

      return sequence_repeats_dict
#+end_src

*** Testing =get_seq_repeat_info()=
#+begin_src python :session gdspyt :tangle no
  for i in range(100):  
      print("\n* ====", i, "====\n")
      print(get_seq_repeat_info(test_sequence, i))
#+end_src

** Printing the frequency of a given repeat in a file 
#+begin_src python :session gdspyt :tangle ./repeats.py
  def repeat_times_file(fasta_dict, repeat):
      """this returns the the frequency of occurance of a repeat in the file."""

      frequency = 0
      #this loop simply adds the number of times the repeat occurs in each sequence of fasa_dict
      for id, sequence in fasta_dict.items():
          frequency = frequency + get_repeat_frequency(sequence, repeat)

      return frequency
#+end_src

** Getting the repeat information of all unique repeats for all sequences of a file

*** The =get_file_repeat_units(fasta_dictionary, n)= function

#+begin_src python :session gdspyt :tangle ./repeats.py
  def get_file_repeat_units(fasta_dict, n):
      #dictionary storing the non-unique repeat information of the file by calling get_seq_repeat_info()
      file_repeat_info = {}
      for uid, sequence in fasta_dict.items():
          file_repeat_info[uid] = get_seq_repeat_info(sequence, n)

      #dictionary to store the times of occurance of each unique repeat unit in the file 
      file_unit_times_dict = {}
      #to help us keep track of the unique repeat units
      unit_list = []
      for uid, sequence_repeat_info in file_repeat_info.items():
          for repeat_unit, times in sequence_repeat_info.items():
              if repeat_unit in unit_list:
                  file_unit_times_dict[repeat_unit] = file_unit_times_dict[repeat_unit] + times
              else:
                  file_unit_times_dict[repeat_unit] = times
                  unit_list.append(repeat_unit)

      return file_unit_times_dict
#+end_src

*** Testing =get_file_repeat_units()=
#+begin_src python :session gdspyt :tangle no
  from repeats import *
  print("\n\nThe following repeats of length", 8, "have been identified.\n")
  print(get_file_repeat_units(fast_dict, 8))

#+end_src

** Finding the most frequent repeat unit(s) of length 'n' in a file

*** The =max_occurance_n(fasta_dict, n)= function

#+begin_src python :session gdspyt :tangle ./repeats.py
  def max_occurance_n(fasta_dict, n):
      """This function returns the unit(s) with the maximum occurance with the number of times it occured."""

      repeat_units_dict = get_file_repeat_units(fasta_dict, n)
      max_times = 0

      for repeat_unit, times in repeat_units_dict.items():
          if times > max_times:
              max_times = times

      #now we build the max_repeats list. A list is used here because there can be more than one repeat unit with the maximum occurance
      max_repeats_list = []
      #we assign the first position of the max_repeats_list with the max time of occurance 
      max_repeats_list.append(max_times)
      for repeat_unit, times in repeat_units_dict.items():
          if times == max_times:
              max_repeats_list.append(repeat_unit)

      return max_repeats_list
#+end_src

*** Testing =max_occurance_n()=
#+begin_src python :session gdspyt :tangle no 
max_repeats_list = max_occurance_n(fast_dict, 8) 
print(max_repeats_list)
#+end_src

** Printing repeat units of length 'n' with maximum frequency in the file 
#+begin_src python :session gdspyt :tangle ./repeats.py
  def print_max_repeat_n(fasta_dict, n):
      """this function prints the maximum number of times of occurance of repeat units of lengths n and all such repeat units with occur with the maximum frequency"""

      #first we get the max repeats list by calling the max_occurance_n function. remember that the first position of the list returned by the function contains the maximum frequency
      max_repeats_list = max_occurance_n(fasta_dict, n)

      print("\nRepeat(s) of length", n, "occur(s) a max of", max_repeats_list[0], "times in the file.", end = " ")
      print("The following repeats occur at this maximum frequency:")
      i = 1 #because we want to print from the second position of the list
      list_len = len(max_repeats_list)
      while(i < list_len):
          print(max_repeats_list[i])
          i = i + 1 

      return 0
#+end_src
* Creating the UI
Now all that is left to do is to create the UI.
** Taking the input and generating the options 
getopt module (inbuilt)
*** Opening the file 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py
  #!/usr/bin/python3
  import sys
  def usage():
      print
      """
      The program allows the user to ....

      Basic Usage:

      python3 fastinfo.py <filename.FASTA> [option1] [option2...]

      """
      return 0

  #now we open the file, which is stored in the second position of the sys.argv[] list
  try:
      f = open(sys.argv[1], 'r')
      print("FASTA File found. Processing...")
  except IOError:
      print("The file does not exist! Please recheck the filename.")
      sys.exit()

#+end_src
** Broad file operations
*** Importing the parsefasta module and reading the file into a dictionary
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py  
  from parsefasta import *
  fast_dict = multi_FASTA_to_dict(f)
#+end_src
*** Printing the number of sequences of the file 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py  
  print("* Sequence information of the file:")
  print("\nThere are a total of", len(fast_dict), "sequences in the file.")
#+end_src
*** Printing the identifiers of the sequences with their lengths, in a table  
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py  
  print("\nThe following identifiers have been retrieved:\n")
  print("Identifier\t\t\t\t Length")
  print("__________\t\t\t\t ______")
  for keys, sequence in fast_dict.items():
      print(keys, "\t", len(sequence))
#+end_src
*** Printing the longest and shortest sequence of the file
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py  
  from seqlen_compare import *
  seq_len_compare(fast_dict)
#+end_src
** Open Reading frames operations 
*** Importing the =orfs= module 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py
  from orfs import *
#+end_src 

*** Printing all  ORFs in a file 
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
print("* ORFs in the file")
print_orfs_of_file(fast_dict)
#+end_src

*** Printing length of  longest and shortest ORF(s), those ORFs  and the identifiers containing them along with the start and stop positions in the sequence.  
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
  print("* Longest and Shortest ORFs in the file.")
  print_longest_shortest_ORFs(fast_dict)
#+end_src

*** Printing lengths of longest and shortest ORF(s) corresponding to individual frames, and the identifiers containing them along with the start and stop positions along with the coordinates. 
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
  print("* Longest and Shortest ORFs in individual frames.")
  i = 1
  while (i <= 3):
      print("** Frame"+str(i))
      print_longest_shortest_ORFs(fast_dict, i)
      i = i + 1 
#+end_src

*** For a given identifier in the file, what is the longest ORF for that identifier 
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
  print("* Identifier ORFs")
  identifier = "gi|142022655|gb|EQ086233.1|43"
  tester = fast_dict[identifier]
  print("The identifier", identifier, "has ORFs with the following:\n")
  print_seq_orf_info(tester)
#+end_src
** Repeats  operations
*** importing the =repeats.py= module
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
  from repeats import *
#+end_src

*** printing the frequency of a given repeat in a file 
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py
input_repeat_unit = 'GCCGCCG'
print("* Repeat Information")
print("\nThe repeat", input_repeat_unit, "occurs with a frequency of", repeat_times_file(fast_dict, input_repeat_unit))
#+end_src

*** Printing repeat units of length 'n' with maximum frequency in the file 
#+begin_src python :session gdspyt :tangle ./genomic-tools-gdspyt-ui.py 
print_max_repeat_n(fast_dict, 11)
#+end_src


