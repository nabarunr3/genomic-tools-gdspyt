#+title:A set of sequence manipulation code
* Reading from a Given FASTA file
(1) How many records are in the file? A record in a FASTA file is defined as a single-line header, followed by lines of sequence data. The header line is distinguished from the sequence data by a greater-than (">") symbol in the first column. The word following the ">" symbol is the identifier of the sequence, and the rest of the line is an optional description of the entry. There should be no space between the ">" and the first letter of the identifier. 

Separate functions for the following tasks are to be written:
1. Accepting a FASTA file as input from the command line [other arguments if necessary will be accepted later by modifying this code]
2. Reading from a FASTA file and putting sequences into a dictionary
3. Using the dictionary to count and return the number of sequences
** Parsing a FASTA File
*** Opening the file 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py
  #!/usr/bin/python3
  #the following code reads from a FASTA file and puts the sequences in a dictionary
  import sys
  def usage():
      print
      """
      The program allows the user to ....

      Basic Usage:

      python3 fastinfo.py <filename.FASTA> [option1] [option2...]

      """
      return 0

  #now we open the file, which is stored in the second position of the sys.argv[] list
  try:
      f = open(sys.argv[1], 'r')
      print("FASTA File found. Processing...")
  except IOError:
      print("The file does not exist! Please recheck the filename.")
      sys.exit()

#+end_src

*** Putting the sequences of the file in a dictionary
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org
  def multi_FASTA_to_dict(FASTA_file_object):
      """
      This function opens a FASTA file and puts the sequences in a dictionary. 
      """
      sequence_dictionary = {}
      for line in FASTA_file_object:
          line = line.rstrip() #removing the trailing newlines from the FASTA file
          #print(line)
          if line[0] == '>':
              #split the header into a list consisting of the sequence identifier and the description 
              header_word_list = line[1:].split() 
              #identifier would be the first word of the header word list
              identifier = header_word_list[0]
              #print(identifier)
              #initializing an empty entry corresponding to the sequence identifier
              sequence_dictionary[identifier] = ""
              #print(sequence_dictionary[identifier])
          else:
              sequence_dictionary[identifier] = sequence_dictionary[identifier]+line #we concatenate the subsequent lines to the entry corresponding to an identifier
              #print(sequence_dictionary[identifier])

      return sequence_dictionary
#+end_src

*** Printing file information 
Now we print the sequence identifiers in the dictionary and the number of entries in the multi-FASTA file. 
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org 
  fast_dict = multi_FASTA_to_dict(f)
  print("\nThe following identifiers have been retrieved:")
  for keys in fast_dict:
      print(keys)
      #print(fast_dict[keys]) #prints all sequences, hence commented out
  print("\nThere are a total of", len(fast_dict), "sequences in the file.")
#+end_src

*** Printing length information of sequences
#+begin_src python :tangle ./genomic-tools-gdspyt-ui.py :comments org 
  from seqlen_compare import *
  seq_len_compare(fast_dict)
#+end_src
*** Example sequence
#+begin_src python :session gdspyt
test_sequence="AGGCTTGACCTTGTGCGGCAGCCGGCAGCCGCCGGCCGGCAGGTTGCCGTACGGATCCTCGTCGGCCGCCGTCGCGGGGGCCGCCGGCATCACGGGGGCGGTCGACGCGACCAGCATCGGGGGGAACGGCAACGCATGCACCCGCTCGCCGGTCAGCACGAACGCACCGTTGGCCACCGCCGGCGCGATCGGCGGCACGCCGGCGTCGCTCAACCCGGTCGGCTGGGCGTCCGACGGCACGAAGAAGACATCCACCGGCGGCGCTTCCTGCATGCGTATCGGCGAATAGTCGGCGAAACCGGCGTTGCGGACCGCGCCATGGTCGACGTCGATCGCGAAGCCGGGCTTCGTCGTCGCGAGACCGAACAGCGCGCCGCCCTGGATCTGCGCTTGCGCGCCGGTCGGGTTGACGATGCGGCCCGCATACACGCCGGCCGTCACGCGATGCACGCGCGGTTGTTGCGCTTCGATCGACACTTCCGTCACGTACGCGACGACCGAGCCGGCCGTTTCGTGCATCGCGACGCCCCACGCGTGCCCGGCCGGCAGCGTGCGCGCGCCGTAGCCGGACTTGTCGACGGCCAGCGCGAGCGCCTGCCGATGCGCGGCGTGCTCGGGGCCGGCCAGCCGCGTCATCCGGTAGGCGACCGGATCCTGCCGCGCCGAGTGCGCGAGCTCGTCGACCAGCGTTTCCATCACGAACGCCGTATGCGAGTTGCCGCCCGAGCGCCACGTCTGGACCGGCACGTCGGCCTCGGTCTGATGAACCGATACCTGCATCGGGAAGCCGTACGGGCTGTTCGTCACGCCTTCGGTCAGGCTCGGATCGGTGCCGCGCTTGAGCATCGTCGTGCGCTCGAGCGGCGAGCCCTTCAGCACAGACTGGCCGACGACCACGTGCTGCCAGTCGCGCACGGCGCCGCTGCCGTCCACGCCGATGTCGACGCGATGCAGCACCATCGGGCGGTAATAGCCGCCGCGCAGATCGTCCTCGCGCGTCCAGATCGTCTTGACGGGGCCGAGATGGCCGGCCGCGAGGTACGCGGCGGACACGTGGGCGGCTTCGACCACGTAGTCCGACGTCGGCGTCGAGCGCCGGCCATAGTCGCCGCCCGAGGTCAGCGTGAAGATCTGGACTTTCTCCGGGGCGACGCCGAGCGCCTTCGCGACCGCCGCGCGGTCGGTCGTC"
#+end_src

* Comparing sequences in the file

** Question 
#+begin_quote
(2) What are the lengths of the sequences in the file? What is the longest sequence and what is the shortest sequence? Is there more than one longest or shortest sequence? What are their identifiers? 
#+end_quote
** Our Approach 
The way to go about this is:
- Find the length of each seqeunce in the dictionary and put this in another dictionary with keys as the identifiers and values as the length. Use this dictionary for comparison.
- Now, find the longest and shortest sequence and print their identifiers and lengths.
** Creating a dictionary storing identifiers and sequence lengths and printing it 
#+begin_src python :tangle ./seqlen_compare.py :comments org :mkdirp 
  def seq_len_compare(seq_dict):
      """This function compares the length of DNA sequences in a dictionary
      """

      """first, we create a new sequence dictionary which stores lengths against identifiers
      """
      seq_len_dict = {}
      for keys,values in seq_dict.items():
          seq_len_dict[keys] = len(values)

      #for testing     
      # for keys,values in seq_len_dict.items():
      #     print(keys,values)


      """
      Now we compare the lengths of sequences in the dictionary.
      """

      #1. Maximum Length

      #first we initialize the maximum sequence length to 0
      max = 0
      #next we initialize a variable to store the identifier corresponding to the maximum sequence length
      max_identifier = ''
      #now we create a list which holds all identifiers which have the maximum value
      max_list = []
      for keys,values in seq_len_dict.items():
          if values>max:
              max = values
              max_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the maximum length
      for keys,values in seq_len_dict.items():
          if values==max:
              max_list.append(keys)

      #2. Minimum Length 
      #first we initialize the minimum sequence length to the maximum value obtained in the previous section
      min = max 
      #next we initialize a variable to store the identifier corresponding to the minimum sequence length
      min_identifier = ''
      #now we create a list which holds all identifiers which have the minimum value
      min_list = []
      for keys,values in seq_len_dict.items():
          if values<min:
              min = values
              min_identifier = keys

      #next we store all the identifiers in the dictionary which have the value corresponding to the minimum length
      for keys,values in seq_len_dict.items():
          if values==min:
              min_list.append(keys)

      """
      Now we print out the values obtained along with their identifiers.
      """
      #1. Print Maximum Length(s)
      print("\nThe following", len(max_list),  "sequence(s) has/have the maximum length of", max, '.')
      for x in range(len(max_list)):
          #print the identifiers in the max_list
          print("\n", max_list[x])

      #2. Print Minimum Length(s)
      print("\nThe following", len(min_list), "sequence(s) has/have the minimum length of", min,'.')
      for x in range(len(min_list)):
          #print the identifiers in the min_list
          print("\n", min_list[x])

      #to exit from the function
      return 0
#+end_src

* Identification and Mapping of Open Reading Frames (ORFs)
** Question 
#+begin_quote
(3) In molecular biology, a reading frame is a way of dividing the DNA sequence of nucleotides into a set of consecutive, non-overlapping triplets (or codons). Depending on where we start, there are six possible reading frames: three in the forward (5' to 3') direction and three in the reverse (3' to 5'). For instance, the three possible forward reading frames for the sequence AGGTGACACCGCAAGCCTTATATTAGC are: 

AGG TGA CAC CGC AAG CCT TAT ATT AGC

A GGT GAC ACC GCA AGC CTT ATA TTA GC

AG GTG ACA CCG CAA GCC TTA TAT TAG C 

These are called reading frames 1, 2, and 3 respectively. An open reading frame (ORF) is the part of a reading frame that has the potential to encode a protein. It starts with a start codon (ATG), and ends with a stop codon (TAA, TAG or TGA). For instance, ATGAAATAG is an ORF of length 9.

Given an input reading frame on the forward strand (1, 2, or 3) your program should be able to:
1. identify all ORFs present in each sequence of the FASTA file, and answer
2. what is the length of the longest ORF in the file?
3. What is the identifier of the sequence containing the longest ORF?
4. For a given sequence identifier, what is the longest ORF contained in the sequence represented by that identifier?
5. What is the starting position of the longest ORF in the sequence that contains it? The position should indicate the character number in the sequence. For instance, the following ORF in reading frame 1:

>sequence1

ATGCCCTAG

starts at position 1.

Note that because the following sequence:

>sequence2

ATGAAAAAA

does not have any stop codon in reading frame 1, we do not consider it to be an ORF in reading frame 1. 
#+end_quote

** Our Approach 
*** How we define ORFs?
Open Reading Frames are substrings of DNA sequence strings which start with a start codon ATG and end with a stop codon, TAA, TAG or TGA.

Now, a given sequence will have 6 reading frames. Given a sequence, its easy to understand the first 3: we start accepting codons in multiples of 3 from the first position, the second and the third. 

What about the frames 4, 5 and 6? For them, we take the reverse strand, that is, the reverse complement of our sequence and take ORFs in it, as we had done for the forward strand.

The problem with the reverse strand is, we also have to map the starting and ending positions of the ORF, if any.

For example, the sequence
5' CCTCGAGTCTGATTGCATGCAAATG

Has
5' C ATT TGC ATG CAA TCA GAC TCG AGG 3'
*** Complement of Sequence
#+begin_src python  :var seq_str="CCTCGAGTCTGATTGCATGCAAATG" :results output
  def sequence_reverse(sequence):
      """
      This program finds the reverse of the sequence entered. 
      """
      return sequence[]

  print (sequence_reverse(seq_str))
#+end_src

#+RESULTS:
: G


